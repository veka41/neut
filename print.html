<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Neut Programming Language</title>
    <meta name="description" content="A functional programming language with static memory management." />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="css/general.css" />
    <link rel="stylesheet" href="highlight.css" />
    <meta property="og:title" content="Neut Programming Language" />
    <meta property="og:description" content="A functional programming language with static memory management." />
    <meta property="og:url" content="https://vekatze.github.io/neut/print.md" />
    <meta property="og:type" content="article" />
  </head>
  <body>
    <div id="body-container">
      <header id="menu-bar">
        <h1 class="menu-title">
          <a href="overview.html">
            Neut Programming Language
          </a>
        </h1>

        <div class="right-buttons">
            <a href="https://github.com/vekatze/neut" class="menubar-item">
              <span>GitHub</span>
            </a>
        </div>
      </header>
      <div id="content-box">
        <aside id="sidebar">
          <nav class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-external-world.html"><strong aria-hidden="true">3.1.</strong> Hello External World</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
          </nav>
        </aside>

        <main id="content" tabindex="0">
          <article id="content-inner">
            <h1 id="neut-programming-language"><a class="header" href="#neut-programming-language">Neut Programming Language</a></h1>
<p>Neut is a functional programming language with static memory management.</p>
<p>Its key features include:</p>
<ul class="star-list">
  <li>Full λ-calculus support</li>
  <li>Predictable automatic memory management</li>
  <li><em>The absence of annotations to the type system</em> when achieving both of the above</li>
</ul>
<p>Neut doesn't use GCs or regions. Instead, it takes a <em>type-directed approach</em> to handle resources.</p>
<h2 id="what-does-it-look-like"><a class="header" href="#what-does-it-look-like">What Does it Look Like?</a></h2>
<p>Like the following:</p>
<pre><code class="language-neut">// the obligated hello world
define hello(): unit {
  print(&quot;Hello, world!\n&quot;)
}

// algebraic data types
data my-list(a) {
| Nil
| Cons(a, my-list(a))
}

// a recursive function with pattern matching
define noisy-length&lt;a&gt;(xs: my-list(a)): int {
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    let my-message = &quot;hey\n&quot; in
    print(my-message);
    add-int(1, noisy-length(ys))
  }
}
</code></pre>
<h2 id="static-memory-management--but-how"><a class="header" href="#static-memory-management--but-how">Static Memory Management — But How?</a></h2>
<p><em>Neut translates a type into a function</em> that can discard/copy the values of the type. By using those functions, the compiler translates programs so that every variable is used exactly once.</p>
<p>For example, if a variable is used twice, a translation like the following will happen:</p>
<pre><code class="language-neut">// (before)
let xs: list(a) = [value-1, value-2] in
some-func(xs, xs) // `xs` is used twice

// ↓

// (after)
let xs: list(a) = [value-1, value-2] in
let (xs1, xs2) = copy-list-a(xs) in  // `xs` is used once
some-func(xs1, xs2)
</code></pre>
<p>If you need more, see <a href="./how-to-execute-types.html">How to Execute Types</a>.</p>
<p>You may wonder: <em>&quot;So we need to, for example, copy the whole list just to get its length? Isn't it the end of the world?&quot;</em>. This topic is covered in <a href="./static-memory-management.html">Static Memory Management</a>. As written there, Neut avoids such copyings by using the <em>T-necessity operator</em> in modal logic to achieve something like borrowing in Rust.</p>
<h2 id="how-fast-is-this"><a class="header" href="#how-fast-is-this">How Fast is This?</a></h2>
<p><a href="./benchmarks.html">Please see the benchmarks</a>.</p>
<h2 id="list-of-other-basic-characteristics"><a class="header" href="#list-of-other-basic-characteristics">List of Other Basic Characteristics?</a></h2>
<ul>
<li>Call by value</li>
<li>Impure</li>
<li>Compiles to <a href="https://llvm.org/docs/LangRef.html">LLVM IR</a> and binary</li>
<li>The type system ≒ <a href="https://en.wikipedia.org/wiki/Calculus_of_constructions">CoC</a> + <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">ADT</a> + (T-necessity) + (fix) - (universe hierarchy)
<ul>
<li>That is, the usual one in functional programming, but a bit generalized</li>
</ul>
</li>
<li>Built-in <a href="./lovely-lsp-showcase.html">LSP support</a></li>
<li>Built-in <a href="./rapid-prototyping.html">rapid prototyping experience</a> like scripting languages</li>
<li>Built-in formatter like Go</li>
</ul>
<h2 id="anything-else"><a class="header" href="#anything-else">Anything Else?</a></h2>
<p>You might also find Neut's module system interesting. <em>It distinguishes modules using the digests (checksums) of tarballs</em> and defines module identities using version information. Although this is not the main point of the language, it still might be of interest. This topic is covered in the <a href="./hello-external-world.html">tutorial</a>.</p>
<p>Also, Neut includes an LSP server, which provides things like code completion, error reporting on save, etc. See <a href="./lovely-lsp-showcase.html">Lovely LSP Showcase</a> to see it in action.</p>
<hr />
<p>You can press the &quot;→&quot; key to go to the next page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>To install the toolchain, execute <a href="https://raw.githubusercontent.com/vekatze/neut/main/install.sh">the installation script</a>:</p>
<pre><code class="language-sh">curl -sSL https://raw.githubusercontent.com/vekatze/neut/main/install.sh | bash
</code></pre>
<p>Then please follow the instructions.</p>
<p>You may also want to <a href="./editor-setup.html">configure your editor</a>.</p>
<p>If you prefer manual installation, see <a href="./manual-installation.html">here</a>.</p>
<h2 id="uninstallation"><a class="header" href="#uninstallation">Uninstallation</a></h2>
<p>To uninstall,</p>
<ol>
<li>remove the binary <code>~/.local/bin/neut</code>,</li>
<li>remove <code>NEUT_CORE_MODULE_URL</code> and <code>NEUT_CORE_MODULE_DIGEST</code> in your shell config, and</li>
<li>remove cache directories created in your Neut projects (if desired).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>Neut is a <em>module-based</em> <em>functional</em> programming language with <em>static</em> memory management via <em>modality</em>. This chapter is a quick introduction to this language.</p>
<p>In <a href="./hello-external-world.html">Hello External World</a>, we will see Neut's <em>&quot;module-based&quot;</em> aspect. We will see how to use modules in Neut. You'll know how to create, build, execute, and release your modules.</p>
<p>In <a href="./programming-in-neut.html">Programming in Neut</a>, we will see Neut's <em>&quot;functional&quot;</em> aspect. We'll see how to write code in Neut.</p>
<p>In <a href="./static-memory-management.html">Static Memory Management</a>, we will see Neut's <em>&quot;static&quot;</em> aspect. We will see how to handle memory operations in Neut. We'll also see Neut's technique to optimize memory allocation.</p>
<p>In <a href="./modality-and-memory.html">Modality and Memory</a>, we will see how Neut utilizes <em>modality</em>, especially the T-necessity operator, in its memory management.</p>
<p>This chapter assumes you are familiar with languages like Haskell, OCaml, or F#.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-external-world"><a class="header" href="#hello-external-world">Hello External World</a></h1>
<p>In this section, starting from the sacred hello world, we'll see how the development cycle in Neut proceeds.</p>
<h2 id="what-youll-learn-here"><a class="header" href="#what-youll-learn-here">What You'll Learn Here</a></h2>
<p>We'll explore how to use modules in Neut. More Specifically:</p>
<ul>
<li>How to <em>create</em> a module</li>
<li>How to <em>build</em> a module</li>
<li>How to <em>execute</em> a module</li>
<li>How to <em>add</em> dependencies</li>
<li>How to <em>publish</em> your module</li>
</ul>
<h2 id="creating-a-module"><a class="header" href="#creating-a-module">Creating a Module</a></h2>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>Run the following command:</p>
<pre><code class="language-sh">neut create sample
</code></pre>
<p>This command creates a new directory <code>./sample/</code> and files inside the directory. This directory is an example of a module in Neut. A module in Neut is a directory that contains <code>module.ens</code>.</p>
<p>The command <code>create</code> creates a sample project that performs &quot;hello world&quot;. This module can be built and executed by running the following commands:</p>
<pre><code class="language-sh">cd ./sample
neut build sample --execute # =&gt; &quot;Hello, world!&quot;
</code></pre>
<p>Let's see what a module in Neut is like.</p>
<h3 id="structure"><a class="header" href="#structure">Structure</a></h3>
<p>The content should be something like the following:</p>
<pre><code class="language-text">sample/
├── cache/
│  └── ...
├── source/
│  └── sample.nt
└── module.ens
</code></pre>
<p>The directory <code>cache</code> is where object files (binary files) and dependencies are put in. You won't have to go into the directory for daily use.</p>
<p>The directory <code>source</code> is where we put source files.</p>
<p>The file <code>module.ens</code> contains meta information about this project, such as dependencies.</p>
<div class="info-block">
<p>You can change the locations of special directories such as <code>build</code> or <code>source</code> by using <code>module.ens</code>. See <a href="./modules.html">Modules</a> for more information.</p>
</div>
<h3 id="moduleens"><a class="header" href="#moduleens">module.ens</a></h3>
<p>The content of <code>module.ens</code> should be something like the below:</p>
<pre><code class="language-ens">{
  target {
    sample {
      main &quot;sample.nt&quot;,
    },
  },
  dependency {
    core {
      digest &quot;(base64url-encoded checksum)&quot;,
      mirror [
        &quot;https://github.com/.../X-Y-Z.tar.zst&quot;,
      ],
      enable-preset true,
    },
  },
}
</code></pre>
<p><code>target</code> specifies the name and the main file of the resulting executables. In the case above, <code>neut build</code> will create an executable file <code>sample</code> by compiling sources using the <code>main</code> function in <code>sample.nt</code> as the entry point.</p>
<p><code>dependency</code> specifies external dependencies. Since our running example doesn't do much, the only dependency is <code>core</code>, which is the same as &quot;prelude&quot; in other languages.</p>
<p>The <code>digest</code> is the base64url-encoded checksum of the tarball.</p>
<p>The <code>mirror</code> is a list of URLs of the tarball.</p>
<p>The <code>enable-preset</code> makes the <code>core</code> library behave like Prelude in Haskell. That is, when <code>enable-preset</code> is true, specified names in the dependency are automatically imported into every file in our module.</p>
<h3 id="source-files"><a class="header" href="#source-files">Source files</a></h3>
<p>Let's see the content of <code>source/sample.nt</code>:</p>
<pre><code class="language-neut">// sample.nt

define main(): unit {
  print(&quot;Hello, world!\n&quot;) // `print` is defined in `core`
}
</code></pre>
<p>The above code defines a function <code>main</code> that returns a value of type <code>unit</code>. This function prints <code>&quot;Hello, world!\n&quot;</code>.</p>
<p>Here, the <code>unit</code> is an ADT that contains only one value <code>Unit</code>. The explicit definition of <code>unit</code> is as follows:</p>
<pre><code class="language-neut">data unit {
| Unit
}

// The Haskell equivalent of the above is (ignoring variable naming conventions):
//   data unit =
//     Unit
</code></pre>
<p>Let's try editing the code as follows:</p>
<pre><code class="language-neut">// sample.nt
import {
  core.text.io {print-int},
}

define main(): unit {
  print-int(42) // `print-int` is also defined in `core`
}
</code></pre>
<p>Then, build the project:</p>
<pre><code class="language-sh">neut build sample --execute # =&gt; 42
</code></pre>
<p>You can also obtain the resulting binary:</p>
<pre><code class="language-sh">neut build sample --install ./bin # creates a directory `bin` and put the resulting binary there
./bin/sample # =&gt; 42
</code></pre>
<h3 id="defining-a-function"><a class="header" href="#defining-a-function">Defining a function</a></h3>
<p>Of course, you can define a function:</p>
<pre><code class="language-neut">// sample.nt
import {
  core.text.io {print-int},
}

define get-int(): int {
  42
}

define main(): unit {
  print-int(get-int())
}
</code></pre>
<p>A function can take arguments. Let's rewrite <code>sample.nt</code> into the below:</p>
<pre><code class="language-neut">// sample.nt
import {
  core.text.io {print-int},
}

define increment(x: int): int {
  add-int(x, 1)
}

define my-add(x: int, y: int): int {
  add-int(x, y)
}

define main(): unit {
  print-int(my-add(10, increment(10))) // # =&gt; 21
}
</code></pre>
<p>Top-level items like <code>define</code> are called statements. You'll see more in the next section.</p>
<div class="info-block">
<p>As in F#, statements in Neut are order-sensitive. If you were to define <code>main</code> before <code>my-add</code>, the code won't compile. For forward references, you'll have to explicitly declare names beforehand using a statement called <code>nominal</code>, which we'll see in the next section.</p>
</div>
<h2 id="publishing-your-module"><a class="header" href="#publishing-your-module">Publishing Your Module</a></h2>
<p>Let's publish our module so others can use the functions <code>my-add</code> and <code>increment</code>.</p>
<p>You can create an archive of the current module using <code>neut archive</code>:</p>
<pre><code class="language-sh">neut archive 0-1
ls ./archive # =&gt; 0-1.tar.zst
</code></pre>
<p><code>neut archive</code> creates the directory <code>archive</code> at the root of your module. This command also creates an archive for the current module.</p>
<p>The name of a module archive must be something like <code>0-1</code>, <code>2-3-1</code>, <code>1-2-3-4-5-6</code>.</p>
<p>The compiler interprets the names of archives as semantic versions. For example, if you create an archive <code>1-2-3</code> and then <code>1-2-4</code>, the <code>1-2-4</code> is treated as a newer compatible version of <code>1-2-3</code>.</p>
<p>This tarball can be controlled with your version control system like Git and pushed to the remote repository, as usual:</p>
<pre><code class="language-sh"># the usual git thing

pwd # =&gt; path/to/sample/

git init

git commit --allow-empty -m &quot;initial commit&quot;
echo &quot;build&quot; &gt; .gitignore
git add .gitignore archive/ module.ens source/
git commit -m &quot;whatever&quot;

git remote add origin git@github.com:YOUR_NAME/YOUR_REPO_NAME.git
git push origin main
</code></pre>
<p>This tarball can be used as a dependency, as described in the next section.</p>
<h2 id="adding-another-module-to-your-module"><a class="header" href="#adding-another-module-to-your-module">Adding Another Module to Your Module</a></h2>
<p><code>neut get</code> can be used to add external dependencies:</p>
<pre><code class="language-sh"># create a new module
pwd # =&gt; ~/Desktop (for example)
neut create new-item
cd new-item

# ↓ add the previous module to our `new-item`
neut get some-name https://github.com/YOUR_NAME/YOUR_REPO_NAME/raw/main/archive/0-1.tar.zst

# you can try the following command for example:
neut get some-name https://github.com/vekatze/neut-sample/raw/main/archive/0-1.tar.zst
</code></pre>
<p>The command <code>neut get</code> fetches the tarball from the specified URL and adds it to the current module. The module can then be used as <code>some-name</code> in your module.</p>
<p>The information of the newly-added module is saved to <code>module.ens</code>:</p>
<pre><code class="language-ens">{
  target {
    new-item {
      main &quot;new-item.nt&quot;,
    },
  },
  dependency {
    core { .. },
    // ↓ HERE
    some-name {
      digest &quot;..&quot;,
      mirror [
        &quot;https://github.com/YOUR_NAME/YOUR_REPO_NAME/raw/main/archive/0-1.tar.zst&quot;,
      ],
    },
  },
}
</code></pre>
<div class="info-block">
<p>The &quot;real&quot; name of an archive is the digest of the tarball. You define an alias of the module for your convenience.</p>
</div>
<h2 id="using-dependencies"><a class="header" href="#using-dependencies">Using Dependencies</a></h2>
<p>These dependencies can then be used in your code:</p>
<pre><code class="language-neut">// new-item.nt

import {
  core.text.io {print-int},
  some-name.sample {my-add},
}

define main(): unit {
  print-int(my-add(10, 11)) // ← using `my-add`
}
</code></pre>
<p>Let's focus on <code>import</code>. This statement specifies the files we want to use in dependencies.</p>
<p><code>import</code> consists of lines like the one below:</p>
<pre><code class="language-neut">some-name.sample {my-add}
</code></pre>
<p>The first component of such a line (<code>some-name</code>) is our alias of the dependency.</p>
<p>What follows (<code>sample</code>) is the relative path to the file from the source directory of the dependency module. Here, you don't have to write the file extension <code>.nt</code>.</p>
<p>Like <code>{my-add}</code> in the example above, every bullet item of an <code>import</code> can optionally have a list of names. Names in these lists are made available after <code>import</code>, as in the example above.</p>
<p>Suppose you didn't write <code>{my-add}</code>. In this case, you can use the fully-qualified form of <code>my-add</code>:</p>
<pre><code class="language-neut">// new-item.nt

import {
  core.text.io {print-int},
  some-name.sample, // removed `{my-add}`
}

define main(): unit {
  // ↓ using the fully-qualified form of `my-add`
  print-int(some-name.sample.my-add(10, 11))
}
</code></pre>
<p>So far, we have used the file <code>(source-directory)/sample.nt</code> in the dependency. What if the file we want to <code>import</code> isn't at the root of the source directory?</p>
<p>Suppose the dependency <code>some-name</code> contained a file <code>source/entity/item.nt</code>. In this case, the file <code>item.nt</code> can be imported from <code>new-item.nt</code> as follows:</p>
<pre><code class="language-neut">import {
  some-name.entity.item,
}
</code></pre>
<p>We only have to add <code>.entity</code> to specify the path to the file. No surprises.</p>
<h2 id="importing-files-in-the-current-module"><a class="header" href="#importing-files-in-the-current-module">Importing Files in the Current Module</a></h2>
<p>We now know how to import files in dependencies. Using the same idea, we can also (of course) import files in the current module.</p>
<p>Let's create a new file <code>new-item/source/foo/greet.nt</code> with the following content:</p>
<pre><code class="language-neut">// foo/greet.nt

define yo(): unit {
  print(&quot;Yo&quot;)
}
</code></pre>
<p>This file can then be used from <code>new-item/source/new-item.nt</code> as follows:</p>
<pre><code class="language-neut">// new-item.nt

import {
  this.foo.greet {yo},
}

define main(): unit {
  yo()
}
</code></pre>
<p>That is, the name of the current module is always <code>this</code>.</p>
<p><code>import</code> can import multiple files and multiple names at the same time. For example, the following is a valid use of <code>import</code>:</p>
<pre><code class="language-neut">import {
  this.foo.greet {yo},
  some-name.entity.item {add},
}
</code></pre>
<h2 id="prefixed-import"><a class="header" href="#prefixed-import">Prefixed Import</a></h2>
<p>We can also use so-called qualified imports as in Haskell. Let's remember the example of fully-qualified names:</p>
<pre><code class="language-neut">// new-item.nt

import {
  core.text.io {print-int},
  some-name.sample, // removed `{my-add}`
}

define main(): unit {
  // ↓ using the fully-qualified form of `my-add`
  print-int(some-name.sample.my-add(10, 11))
}
</code></pre>
<p>We'll rewrite this example into a &quot;prefixed&quot; form. Firstly, edit the <code>module.ens</code> as follows:</p>
<pre><code class="language-ens">{
  target {..},
  prefix {                  //
    S &quot;some-name.sample&quot;,   // ← alias: S -&gt; some-name.sample
  },                        //
  dependency {..},
}
</code></pre>
<p>By registering aliases of files in <code>module.ens</code>, you'll be able to use prefixes as aliases for specified files.</p>
<p>We can now rewrite the <code>new-item.nt</code> as follows:</p>
<pre><code class="language-neut">// new-item.nt

import {
  S, // == some-name.sample
  core.text.io {print-int},
}

define main(): unit {
  print-int(S.my-add(10, 11))
}
</code></pre>
<div class="info-block">
<p>Unlike Haskell, these prefixes are defined per module, not per file. The prefixes of a file must be consistent inside a module.</p>
</div>
<h2 id="what-youve-learned-here"><a class="header" href="#what-youve-learned-here">What You've Learned Here</a></h2>
<ul>
<li>Use <code>neut create MODULE_NAME</code> to create a module</li>
<li>Use <code>neut build TARGET_NAME</code> to build modules</li>
<li>Use <code>neut build TARGET_NAME --execute</code> to execute modules</li>
<li>Use <code>neut get</code> to add external dependencies</li>
<li>Use <code>neut archive</code> and push it to publish modules</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-in-neut"><a class="header" href="#programming-in-neut">Programming in Neut</a></h1>
<p>Now that we know how to deal with modules, let's write programs in Neut.</p>
<h2 id="what-youll-learn-here-1"><a class="header" href="#what-youll-learn-here-1">What You'll Learn Here</a></h2>
<ul>
<li>How to define and use variables</li>
<li>How to define and use functions</li>
<li>How to define and use ADTs</li>
<li>How to perform parallel computations</li>
<li>Other syntactic utilities</li>
</ul>
<h2 id="programming-in-neut-1"><a class="header" href="#programming-in-neut-1">Programming in Neut</a></h2>
<h3 id="variables-and-functions"><a class="header" href="#variables-and-functions">Variables and Functions</a></h3>
<p>Below is an example of the use of variables and functions:</p>
<pre><code class="language-neut">define hey(): unit {
  let x = &quot;hello&quot; in
  let y: int = 100 in
  let z: float = 3.8 in
  print(&quot;hey&quot;)
}
</code></pre>
<p>As in the above example, you can use <code>let</code> to define variables.</p>
<p>If you build the above code, you should notice that the compiler reports unused variables (<code>x</code>, <code>y</code>, and <code>z</code> in the example above). You can use the name <code>_</code> when defining variables to suppress those warnings:</p>
<pre><code class="language-neut">define hey(): unit {
  // 🌟
  let _ = &quot;hello&quot; in
  let _: int = 100 in
  let _: float = 3.8 in
  print(&quot;hey&quot;)
}
</code></pre>
<p><code>let</code>s can be nested:</p>
<pre><code class="language-neut">define hey(): unit {
  let x =
    // 🌟
    let y: int = 100 in
    let z: float = 3.8 in
    &quot;hello&quot;
  in
  print(x) // =&gt; hello
}
</code></pre>
<p>You can use <code>e1; e2</code> as a syntax sugar of <code>let _: unit = e1 in e2</code>:</p>
<pre><code class="language-neut">define hey(): unit {
  // 🌟
  print(&quot;a&quot;);
  print(&quot;b&quot;)
}

// ↓ (desugar)

define hey(): unit {
  let _ = print(&quot;a&quot;) in
  print(&quot;b&quot;)
}
</code></pre>
<h3 id="defining-functions-at-the-top-level"><a class="header" href="#defining-functions-at-the-top-level">Defining Functions at the Top Level</a></h3>
<p>You can use the statement <code>define</code> to define functions:</p>
<pre><code class="language-neut">// 🌟
// defining an ordinary function
define my-func1(x1: int, x2: bool): bool {
  x2
}

// 🌟
// defining a recursive function
define my-func2(cond: bool): int {
  if cond {
    1
  } else {
    my-func2(not(cond)) // recursive call of `my-func2`
  }
}
</code></pre>
<p><code>define</code> can also define a function with implicit arguments (or &quot;generics&quot;):</p>
<pre><code class="language-neut">// 🌟
// The `a` in the angle bracket is the implicit argument of `id`
define id&lt;a&gt;(x: a): a {
  x
}

define use-id(): int {
  let str = 10 in
  id(str) // calling `id` without specifying `a` explicitly
}
</code></pre>
<p>The definition of <code>id</code> in the example above is the same as the below:</p>
<pre><code class="language-neut">// you can explicitly write the type of `a`
define id&lt;a: type&gt;(x: a): a { // `type` is the type of types
  x
}
</code></pre>
<p>We can define <code>id</code> without using any implicit arguments as follows (just for comparison):</p>
<pre><code class="language-neut">define id(a: type, x: a): a {
  x
}

// using `id`
define use-id(): int {
  let str = 10 in
  id(int, str) // ← the first argument `int` is now made explicit
}
</code></pre>
<h3 id="defining-functions-in-a-body-of-a-function"><a class="header" href="#defining-functions-in-a-body-of-a-function">Defining Functions in a Body of a Function</a></h3>
<p>You can use <code>function</code> to define an anonymous function:</p>
<pre><code class="language-neut">define foo() {
  let f =
    // 🌟
    function (x: int, cond: bool) {
      if cond {
        x
      } else {
        add-int(x, 1)
      }
    }
  in
  f(10, False) // → 11
}
</code></pre>
<p>You can also use <code>define</code> in the body of a function to define recursive functions:</p>
<pre><code class="language-neut">define foo() {
  let f =
    // 🌟
    define print-multiple-hellos(counter: int) {
      if eq-int(counter, 0) {
        Unit
      } else {
        print(&quot;hello\n&quot;);
        print-multiple-hellos(sub-int(counter, 1))
      }
    }
  in
  f(10) // prints 10 &quot;hello&quot;s
}
</code></pre>
<div class="info-block">
<p>The compiler reports an error if you rewrite the example above so that it uses the variable <code>f</code> more than once. This behavior is to avoid unexpected copying of values. You can satisfy the compiler by renaming <code>f</code> into <code>!f</code>. The next section will cover this topic.</p>
</div>
<h3 id="calling-functions"><a class="header" href="#calling-functions">Calling Functions</a></h3>
<p>Functions <code>f</code> can be called against arguments <code>e1</code>, ..., <code>en</code> by writing <code>f(e1, ..., en)</code>:</p>
<pre><code class="language-neut">define my-func(x: int, y: int): int {
  // 🌟
  add-int(x, y)
}

define use-my-func(): int {
  // 🌟
  my-func(10, 20)
}
</code></pre>
<p>The syntax sugar <code>of</code> can be used to rewrite the above <code>use-my-func</code> into the below:</p>
<pre><code class="language-neut">define use-my-func(): int {
  // 🌟
  my-func of {
    x = 10,
    y = 20,
  }
}
</code></pre>
<p>A lot of primitive functions (from LLVM) are also available. Please see <a href="./primitives.html">Primitives</a> for more.</p>
<h3 id="defining-adts"><a class="header" href="#defining-adts">Defining ADTs</a></h3>
<p>You can use the statement <code>data</code> to define ADTs:</p>
<pre><code class="language-neut">// 🌟
data my-nat {
| My-Zero
| My-Succ(my-nat)
}
// In Haskell:
//   data my-nat
//     = My-Zero
//     | My-Succ my-nat


//------------

// 🌟
data my-list(a) {
| My-Nil
| My-Cons(a, my-list(a))
}
// In Haskell:
//   data my-list a
//     = My-Nil
//     | My-Cons a (my-list a)
</code></pre>
<p>Arguments in constructors can optionally have explicit names:</p>
<pre><code class="language-neut">data config {
  // 🌟
| Config(count: int, cond: bool)
}
</code></pre>
<p>You may want to write this vertically using a trailing comma:</p>
<pre><code class="language-neut">data config {
  // 🌟
| Config(
    count: int,
    cond: bool,
  )
}
</code></pre>
<h3 id="creating-adt-values"><a class="header" href="#creating-adt-values">Creating ADT Values</a></h3>
<p>You can use constructors as usual functions:</p>
<pre><code class="language-neut">define make-my-list(): my-list(int) {
  // 🌟
  My-Cons(1, My-Cons(2, My-Nil))
}

define make-config(): term {
  // 🌟
  Config of {
    count = 10,
    cond = True,
  }
}
</code></pre>
<h3 id="using-adt-values"><a class="header" href="#using-adt-values">Using ADT values</a></h3>
<p>You can use <code>match</code> to destructure ADT values:</p>
<pre><code class="language-neut">define sum(xs: my-list(int)): int {
  // 🌟
  match xs {
  | My-Nil =&gt;
    0
  | My-Cons(y, ys) =&gt;
    add-int(y, sum(ys))
  }
}
</code></pre>
<p>Nested matching is also possible:</p>
<pre><code class="language-neut">define foo(xs: my-list(int)): int {
  match xs {
  | My-Nil =&gt;
    0
    // 🌟
  | My-Cons(y, My-Cons(z, My-Nil)) =&gt;
    1
  | My-Cons(_, _) =&gt;
    2
  }
}
</code></pre>
<p>Incidentally, the core library defines <code>bool</code> as follows:</p>
<pre><code class="language-neut">// 🌟
data bool {
| False
| True
}
</code></pre>
<p>A syntax sugar <code>if</code> is there to use this <code>bool</code> as in other languages:</p>
<pre><code class="language-neut">define factorial(n: int) {
  // 🌟
  if le-int(n, 0) { // `le-int(n, 0)` means `n &lt;= 0`
    1
  } else {
    mul-int(n, sub-int(n, 1)) //  n * (n - 1)
  }
}
</code></pre>
<p>The result of <code>if</code> can be bound to a variable:</p>
<pre><code class="language-neut">define yo(cond: bool) {
  let x =
    // 🌟
    if cond {
      1
    } else {
      2
    }
  in
  print-int(x)
}

</code></pre>
<h3 id="admit"><a class="header" href="#admit"><code>admit</code></a></h3>
<p>You can use <code>admit</code> to postpone implementing a function and just satisfy the type checker:</p>
<pre><code class="language-neut">define my-complex-function(x: int, y: bool): int {
  // 🌟
  admit
}
</code></pre>
<h3 id="assert"><a class="header" href="#assert"><code>assert</code></a></h3>
<p>You can use <code>assert</code> as follows:</p>
<pre><code class="language-neut">// factorial
define fact(n: int): int {
  // 🌟
  assert &quot;n must be non-negative&quot; {
    ge-int(n, 0)
  };
  if eq-int(n, 0) {
    1
  } else {
    let next = sub-int(n, 1) in
    mul-int(n, fact(next))
  }
}
</code></pre>
<p>The type of <code>assert &quot;..&quot; { .. }</code> is <code>Unit</code>.</p>
<p><code>assert</code> checks if a given condition is satisfied. If the condition is True, it does nothing. Otherwise, it reports that the assertion has failed and kills the program with exit code <code>1</code>.</p>
<p>If you pass <code>--mode release</code> to <code>neut build</code>, <code>assert</code> does nothing.</p>
<h3 id="parallel-computation"><a class="header" href="#parallel-computation">Parallel Computation</a></h3>
<p>You can use <code>detach</code> and <code>attach</code> to perform parallel computation:</p>
<pre><code class="language-neut">define foo(): unit {
  let t1: thread(unit) =
    // 🌟
    detach {
      let value = some-heavy-computation() in
      print(value)
    }
  in
  let t2: thread(unit) =
    // 🌟
    detach {
      let value = other-heavy-computation() in
      print(value)
    }
  in
                 // 🌟
  let result-1 = attach { t1 } in
                 // 🌟
  let result-2 = attach { t2 } in
  Unit
}
</code></pre>
<p><code>detach</code> receives a term of type <code>t</code> and turns it into a term of type <code>thread(t)</code>. Internally, <code>detach</code> creates a new thread and computes the term in that thread.</p>
<p><code>attach</code> receives a term of type <code>thread(t)</code> and turns it into a term of type <code>t</code>. Internally, <code>attach</code> waits for a given thread to finish and extracts its result.</p>
<h3 id="auxiliary-syntaxes"><a class="header" href="#auxiliary-syntaxes">Auxiliary Syntaxes</a></h3>
<ul>
<li>Additional syntax sugars are also available. For more, please see the <a href="./terms.html#use-e-x-in-cont">language reference</a>.</li>
<li>If you want to call foreign functions (FFI), please see the <a href="statements.html#foreign">here</a>.</li>
</ul>
<h2 id="what-youve-learned-here-1"><a class="header" href="#what-youve-learned-here-1">What You've Learned Here</a></h2>
<ul>
<li>Use <code>let</code> to define variables.</li>
<li>Use <code>function</code> or <code>define</code> to define functions</li>
<li>Use <code>f(e1, ..., en)</code> to call functions</li>
<li>Use <code>data</code> to define ADTs.</li>
<li>Constructors of ADTs are normal functions.</li>
<li>Use <code>match</code> to destruct ADT values</li>
<li>Use <code>detach</code> and <code>attach</code> to perform parallel computation</li>
<li>You can find other syntax sugars in the <a href="./terms.html#syntax-sugar">language reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-memory-management"><a class="header" href="#static-memory-management">Static Memory Management</a></h1>
<p>Here, we'll see how to write performant programs in Neut.</p>
<h2 id="what-youll-learn-here-2"><a class="header" href="#what-youll-learn-here-2">What You'll Learn Here</a></h2>
<ul>
<li>How memory regions are handled in Neut</li>
<li>How to bypass copying resources</li>
<li>How Neut optimizes memory allocations/deallocations</li>
</ul>
<h2 id="linearity-and-memory"><a class="header" href="#linearity-and-memory">Linearity and Memory</a></h2>
<p>In Neut, the content of a variable is <em>copied</em> according to its type <em>if the variable is used more than once</em>. Consider the following code:</p>
<pre><code class="language-neut">// before compilation (pseudo code)
define foo(xs: list(int)): list(int) {
  let ys = xs in // use `xs` (1)
  let zs = xs in // use `xs` (2)
  some-func(ys);
  other-func(zs);
  xs // use `xs` (3)
}
</code></pre>
<p>In the above code, the variable <code>xs</code> is used three times. Because of that, the content of <code>xs</code> is copied twice:</p>
<pre><code class="language-neut">// after compilation (pseudo-code)
define foo(xs: list(int)): list(int) {
  let xs1 = COPY-VALUE(list(int), xs) in
  let xs2 = COPY-VALUE(list(int), xs) in
  let ys = xs1 in
  let zs = xs2 in
  some-func(ys);
  other-func(zs);
  xs
}
</code></pre>
<p>Also, the content of a variable is <em>discarded</em> <em>if the variable isn't used</em>. Consider the following code:</p>
<pre><code class="language-neut">// before compilation
define bar(xs: list(int)): unit {
  Unit
}
</code></pre>
<p>In the above code, since <code>xs</code> isn't used, the content of <code>xs</code> is discarded as follows:</p>
<pre><code class="language-neut">// after compilation (pseudo-code)
define bar(xs: list(int)): unit {
  let _ = DISCARD-VALUE(list(int), xs) in
  Unit
}
</code></pre>
<p>Technically speaking, these discarding/copying operations also happen when the variable is an immediate value like an integer:</p>
<pre><code class="language-neut">define buz(x: int): unit {
  Unit
}

↓


// pseudo-code
define bar(x: int): unit {
  let _ = DISCARD-VALUE(int, x) in
  Unit
}
</code></pre>
<p>In practice, however, discarding/copying operations on immediate values are optimized away.</p>
<p>In the literature, a use of a variable is called <em>linear</em> if the variable is used exactly once. Neut's compiler translates programs so that every non-linear use of variables becomes linear, ignoring arguments in discarding/copying functions.</p>
<p>If you're interested in how Neut achieves these discarding/copying operations, please see <a href="./how-to-execute-types.html">How to Execute Types</a>.</p>
<h3 id="to-be-conscious-of-cloning-values"><a class="header" href="#to-be-conscious-of-cloning-values">To Be Conscious of Cloning Values</a></h3>
<p>Suppose the content of a variable were to be copied simply by using it more than once. In that case, we might suffer from unintended cloning and encounter unexpected performance degradation.</p>
<p>The compiler thus requires us to prefix the name of a variable with <code>!</code> when the variable needs to be copied. Let's consider the following code:</p>
<pre><code class="language-neut">define make-pair(xs: list(int)): pair(list(int), list(int)) {
  Pair(xs, xs)
}
</code></pre>
<p>When checking this code, the compiler will report an error because the code uses the variable <code>xs</code> twice and the variable isn't prefixed with <code>!</code>.</p>
<p>You can satisfy the compiler by renaming <code>xs</code> into <code>!xs</code>:</p>
<pre><code class="language-neut">define make-pair(!xs: list(int)): pair(list(int), list(int)) {
  Pair(!xs, !xs)
}
</code></pre>
<h3 id="free-variables-in-a-local-recursion"><a class="header" href="#free-variables-in-a-local-recursion">Free Variables in a Local Recursion</a></h3>
<p>This <code>!</code> is also required when using a free variable in a term-level <code>define</code>:</p>
<pre><code class="language-neut">define multi-print(!message: text): unit {
  let f =
    define self(counter: int): unit {
      if ge-int(counter, 10) {
        Unit
      } else {
        // `!message` is a free variable of `self`
        printf(&quot;message: {}\n&quot;, [!message]);
        self(add-int(counter, 1))
      }
    }
  in
  f(0)
}
</code></pre>
<p>This is because free variables in a term-level <code>define</code> are cloned during recursion. Seeing how the above code is compiled might be illuminating:</p>
<pre><code class="language-neut">// `self` is now closed thanks to the new parameter `!m` (lambda lifting)
define self(counter: int, !m: text): unit {
  if ge-int(counter, 10) {
    Unit
  } else {
    // 💫 note that `!m` is used twice
    printf(&quot;message: {}\n&quot;, [!m]);
    self(add-int(counter, 1), !m)
  }
}

define multi-print(!message: text): unit {
  let f =
    function (counter: int) {
      self(counter, !message)
    }
  in
  f(0)
}
</code></pre>
<h3 id="cloning-values-for-free"><a class="header" href="#cloning-values-for-free">Cloning Values For Free</a></h3>
<p>The prefix <code>!</code> is unnecessary if the variable can be copied for free. For example, the following code will typecheck:</p>
<pre><code class="language-neut">define make-pair(x: int): pair(int, int) {
  Pair(x, x)
}
</code></pre>
<p>because we can &quot;copy&quot; integers for free (by simply using the same <code>x</code> twice).</p>
<h2 id="the-problem-excessive-copying"><a class="header" href="#the-problem-excessive-copying">The Problem: Excessive Copying</a></h2>
<p>Now, suppose we defined a function <code>length</code> as follows:</p>
<pre><code class="language-neut">define length(xs: list(int)): int {
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}
</code></pre>
<p>Also, suppose that we used this <code>length</code> as follows:</p>
<pre><code class="language-neut">define use-length(!xs: list(int)): unit {
  let len = length(!xs) in // use `length` to calculate the length of `!xs`
  some-function(len, !xs) // then use `len` and `!xs`
}
</code></pre>
<p>Note that the variable <code>!xs</code> is used twice. Therefore, in this example, the content of <code>!xs</code> is copied <em>just to calculate its length</em>. This is a disaster. The end of the world. Every wish is crushed into pieces.</p>
<p>Luckily, there is a loophole for this situation.</p>
<h2 id="the-solution-noema-type"><a class="header" href="#the-solution-noema-type">The Solution: Noema Type</a></h2>
<p>We need a way to bypass excessive copying. Here come <em>noema types</em>.</p>
<p>For any type <code>t</code>, Neut has a type <code>&amp;t</code>. We'll call this the noema type of <code>t</code>. Let's introduce some terminologies:</p>
<ul>
<li>We'll call a term <code>e</code> a noema if the type of <code>e</code> is a noema type.</li>
<li>We'll say that a term is noetic if the type of the term is a noema type.</li>
</ul>
<p>Unlike ordinary terms, <em>a noema isn't discarded or copied even when used non-linearly</em>. By using this behavior, we can avoid the disaster we have just seen.</p>
<p>Let's see how it works. We first redefine <code>length</code>. If the type <code>t</code> is an ADT type, you can inspect its content using <code>case</code>:</p>
<pre><code class="language-neut">define length(xs: &amp;list(int)): int {
  case xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}
</code></pre>
<p>The main difference between <code>case</code> and <code>match</code> is that <code>case</code> doesn't perform <code>free</code> against its arguments. Because of that, this new <code>length</code> doesn't consume <code>xs</code>.</p>
<p>Also, note that the newly-bound variables in <code>case</code> are automatically wrapped with <code>&amp;(_)</code>. For example, in the above example, the type of <code>ys</code> is not <code>list(int)</code>, but <code>&amp;list(int)</code>.</p>
<p>The <code>use-length</code> then becomes as follows:</p>
<pre><code class="language-neut">define use-length(xs: list(int)): unit {
  let len = length( ??? ) in
  some-function(len, xs)
}
</code></pre>
<p>We need a way to create a noetic version of <code>xs: list(int)</code>.</p>
<h2 id="creating-a-noema"><a class="header" href="#creating-a-noema">Creating a Noema</a></h2>
<p>We can create a noema using <code>let-on</code>.</p>
<pre><code class="language-neut">define use-length(xs: list(int)): unit {
  // 🌟
  let len on xs =
    // xs: &amp;list(int)
    length(xs)
  in
  // xs: list(int)
  some-function(len, xs)
}
</code></pre>
<p><code>on</code> takes a comma-separated list of variables. Variables specified there are then cast to a noema in the body of the <code>let</code> and cast back to non-noetic values in its continuation.</p>
<p>The syntax <code>let-on</code> is conceptually the following syntax sugar:</p>
<pre><code class="language-neut">let result on x = e in
cont

// ↓ desugar

let x = unsafe-cast(a, &amp;a, x) in // cast: `a` ~&gt; `&amp;a`
let result = e in                // (use `&amp;a`)
let x = unsafe-cast(&amp;a, a, x) in // uncast: `&amp;a` ~&gt; `a`
cont
</code></pre>
<p>We'll call the content of noetic value <code>xs</code> a <em>hyle</em>. In the example, the hyle of <code>xs</code> at <code>length(xs)</code> is <code>[1, 2, 3]</code>.</p>
<p>The result of <code>let-on</code> (that is, <code>len</code> in this case) can't include any noetic term. This restriction is required so that a noetic value won't outlive its hyle. If interested, please see the <a href="terms.html#on">corresponding part of the language reference</a> for more information.</p>
<h2 id="embodying-a-noema"><a class="header" href="#embodying-a-noema">Embodying a Noema</a></h2>
<p>Incidentally, you can also create a value of type <code>a</code> from a value of type <code>&amp;a</code>, as follows:</p>
<pre><code class="language-neut">define make-pair-from-noema&lt;a&gt;(x: &amp;a): pair(a, a) {
  Pair(*x, *x)
}
</code></pre>
<p>By writing <code>*e</code>, you can clone the hyle of the noema <code>e</code> along the type <code>a</code>, keeping the hyle intact.</p>
<h2 id="allocation-canceling"><a class="header" href="#allocation-canceling">Allocation Canceling</a></h2>
<p>Let's see another aspect of Neut's memory management. The compiler can sometimes optimize away memory allocation thanks to its static nature. Consider the following code:</p>
<pre><code class="language-neut">data int-list {
| Nil
| Cons(int, int-list)
}

// [1, 5, 9] =&gt; [2, 6, 10]
define increment(xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    Nil
  | Cons(x, rest) =&gt; // ← &quot;the `Cons` clause&quot;
    let foo = add-int(x, 1) in
    let bar = increment(rest) in
    Cons(foo, bar)
  }
}
</code></pre>
<p>The expected behavior of the <code>Cons</code> clause would be something like the following:</p>
<ol>
<li>obtain <code>x</code> and <code>rest</code> from <code>xs</code></li>
<li><code>free</code> the outer tuple of <code>xs</code></li>
<li>calculate <code>foo (= add-int(x, 1))</code> and <code>bar (= increment(rest))</code></li>
<li>allocate memory region using <code>malloc</code> to represent <code>Cons(foo, bar)</code></li>
<li>store the calculated values to the pointer and return it</li>
</ol>
<p>However, the compiler knows the following two facts during compilation:</p>
<ul>
<li>The size of outer tuples of <code>Cons(x, rest)</code> and <code>Cons(foo, bar)</code> are the same</li>
<li>The outer tuple of <code>Cons(x, rest)</code> will never be used after extracting its contents</li>
</ul>
<p>Thanks to this knowledge, the compiler can optimize away a pair of <code>free</code> and <code>malloc</code>, as follows:</p>
<ol>
<li>obtain <code>x</code> and <code>rest</code> from <code>xs</code></li>
<li>calculate <code>foo (= add-int(x, 1))</code> and <code>bar (= increment(rest))</code></li>
<li>store the calculated values to <code>xs</code> (overwrite)</li>
</ol>
<p>When a <code>free</code> is required, the compiler looks for a <code>malloc</code> in the continuation that is the same size and optimizes away such a pair if one exists. The resulting assembly code thus performs in-place updates.</p>
<h3 id="how-effective-is-this-optimization"><a class="header" href="#how-effective-is-this-optimization">How Effective Is This Optimization?</a></h3>
<p>Below is the result of benchmarking of a bubble sorting program. This test creates a random list of length <code>N</code> and performs bubble sort on the list.</p>
<p><img src="./image/graph/allocation-canceling.png" alt="allocation canceling" title="allocation canceling" /></p>
<p>This benchmark executes the following <code>sort</code> function:</p>
<pre><code class="language-neut">data int-list {
| My-Nil
| My-Cons(int, int-list)
}

nominal {
  _insert(v: int, xs: int-list): int-list,
}

// 🌟
inline _swap-gt(cond: bool, v: int, x: int, xs: int-list): int-list {
  if cond {
    My-Cons(x, _insert(v, xs))
  } else {
    My-Cons(v, My-Cons(x, xs))
  }
}

define _insert(v: int, xs: int-list): int-list {
  match xs {
  | My-Nil =&gt;
    My-Cons(v, My-Nil)
  | My-Cons(y, ys) =&gt;
    _swap-gt(gt-int(v, y), v, y, ys)
  }
}

define sort(xs: int-list, acc: int-list): int-list {
  match xs {
  | My-Nil =&gt;
    acc
  | My-Cons(y, ys) =&gt;
    sort(ys, _insert(y, acc))
  }
}

</code></pre>
<p>The above is the &quot;faster&quot; implementation of bubble sorting in Neut. The key person is <code>_swap-gt</code>. The above code defines <code>_swap-gt</code> as an inline function. Therefore, in <code>_insert</code>, the definition of <code>_swap-gt</code> is expanded, which makes allocation canceling of <code>My-Cons</code> in <code>_insert</code> possible.</p>
<p>The &quot;slower&quot; implementation can be obtained by replacing <code>inline</code> at the 🌟 with <code>define</code>. In this implementation, since the definition of <code>_swap-gt</code> can't be expanded in <code>_insert</code>, allocation canceling of <code>My-Cons</code> in <code>_insert</code> is not possible.</p>
<p>I also added the result of Haskell just for reference.</p>
<p>Additional notes:</p>
<ul>
<li>You can find the source files used in this benchmark <a href="https://github.com/vekatze/neut/tree/main/bench/action/bubble/source">here</a>.</li>
<li>I used my M1 Max MacBook Pro (32GB) to run this benchmark.</li>
</ul>
<p>If you're interested in more benchmarking results, please see <a href="./benchmarks.html">Benchmarks</a>.</p>
<h2 id="what-youve-learned-here-2"><a class="header" href="#what-youve-learned-here-2">What You've Learned Here</a></h2>
<ul>
<li>Neut uses noema types to bypass copying resources</li>
<li>The compiler finds pairs of <code>malloc/free</code> that are the same size and optimizes them away</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modality-and-memory"><a class="header" href="#modality-and-memory">Modality and Memory</a></h1>
<p>At first glance, the <code>let-on</code> stuff in the previous section might seem a bit artificial.</p>
<p>This <code>let-on</code> can actually be understood as a syntax sugar over the T-necessity operator. Below, we'll first see how Neut incorporates the necessity modality and then how <code>let-on</code> is desugared using the modality.</p>
<h2 id="what-youll-learn-here-3"><a class="header" href="#what-youll-learn-here-3">What You'll Learn Here</a></h2>
<ul>
<li>How layers in Neut are organized</li>
<li>How to introduce &quot;boxed&quot; terms</li>
<li>How to use &quot;boxed&quot; terms</li>
<li>How the borrowing-like operation in Neut is organized using the T-necessity operator</li>
</ul>
<h2 id="introducing-the-concept-of-layers"><a class="header" href="#introducing-the-concept-of-layers">Introducing the Concept of Layers</a></h2>
<p>For every type <code>a</code>, Neut has a type <code>meta a</code>. As we will see, this <code>meta</code> is a necessity operator, often written as <code>□</code> in the literature.</p>
<p>In Neut, given <code>e: a</code>, you can create values of type <code>meta a</code> by writing something like <code>box {e}</code>. Here, the <code>e</code> is not arbitrary since, if so, we must admit propositions like <code>a -&gt; □a</code>, making every truth a necessary truth.</p>
<p>In Neut, the condition that <code>e</code> must satisfy is described using <em>layers</em>. So, before using <code>box</code>, let's learn what layers are like.</p>
<h3 id="the-basics-of-layers"><a class="header" href="#the-basics-of-layers">The Basics of Layers</a></h3>
<p>For every term in Neut, an integer value called <em>layer</em> is defined.</p>
<p>Let's see how layers are calculated. The layer of the body of a <code>define</code> is defined to be 0:</p>
<pre><code class="language-neut">define foo(): unit {
  // here is layer 0
  Unit
}
</code></pre>
<p>If you define a variable at layer N, the layer of the variable is also N:</p>
<pre><code class="language-neut">// here is layer N

let x = Unit in
x // ← `x` is a variable at layer N
</code></pre>
<p>The layer of (an occurrence of) a constant is defined to be the layer in which the constant is used:</p>
<pre><code class="language-neut">define my-func(): int {
  10
}

define use-my-func() {
  // layer 0
  let v1 =
    my-func() // ← this `my-func` is at layer 0
  in

  ... // ← some layer operations here

  // layer 3 (for example)
  let v2 =
    my-func() // ← this `my-func` is at layer 3
  in

  ...
}
</code></pre>
<p>Terms that aren't related to modality won't change layers. For example, the following is the layer structure of <code>function</code> and <code>let</code>:</p>
<pre><code class="language-neut">// here is layer N
function (x1: a1, ..., xn: an) {
  // here is layer N
  e
}

// here is layer N
let x =
  // here is layer N
  e1
in
// here is layer N
// (x: a at layer N)
e2
</code></pre>
<p>As long as you don't use modality-related terms, the layer of a term (and a subterm) is always 0.</p>
<h3 id="layers-and-variables"><a class="header" href="#layers-and-variables">Layers and Variables</a></h3>
<p>In Neut, <em>a variable defined at layer n can only be used at layer n</em>. For example, the following is not a valid term:</p>
<pre><code class="language-neut">define bar(): unit {
  // here is layer 0
  let x = Unit in // ← `x` is defined at layer 0

  ... // ← some layer operations here

  // layer 3 (for example)
  let v2 =
    x // ← ERROR
  in

  ...
}

</code></pre>
<p>This is because the variable <code>x</code> is defined at layer 0 but used at layer 3 (≠ 0).</p>
<h2 id="-introduction-putting-values-into-boxes"><a class="header" href="#-introduction-putting-values-into-boxes">□-Introduction: Putting Values into Boxes</a></h2>
<p>Now that we have layers, we can talk about how to interact with values of type <code>meta a</code>.</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>A term of type <code>meta a</code> can be created using the syntactic construct <code>box</code>.</p>
<p>The syntax of <code>box</code> is as follows:</p>
<pre><code class="language-neut">// here is layer (n+1)
// - x1: &amp;a1 at (n+1)
// - ...
// - xm: &amp;am at (n+1)
box x1, ..., xm {
  // here is layer n
  // - x1: a1 at n
  // - ...
  // - xm: am at n
  e1
}
</code></pre>
<p>Given a term <code>e: A</code>, the type of <code>box x1, ..., xn {e}</code> is <code>meta A</code>.</p>
<p>Note that the types of <code>xi</code>s must be of the form <code>&amp;A</code>.</p>
<p><code>box</code> turns <code>&amp;a1, ..., &amp;an</code> into <code>a1, ..., an</code> inside its body.</p>
<h3 id="semantics"><a class="header" href="#semantics">Semantics</a></h3>
<p>Operationally, <code>box x1, ..., xn { e }</code> copies all the <code>x1, ..., xn</code> and executes <code>e</code>:</p>
<pre><code class="language-neut">box x1, ..., xn { e }

↓

// psueudo-code
let x1 = copy(x1) in
...
let xn = copy(xn) in
e
</code></pre>
<p>As you can see from the above semantics, terms of type <code>meta a</code> have the same forms as <code>a</code>. Thus, the type <code>meta a</code> is compiled into the same closed function as <code>a</code>.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Let's see some examples. Below is an example of <code>box</code>:</p>
<pre><code class="language-neut">define some-function(x: &amp;int): meta int {
  // here is layer 0
  // (x: &amp;int at 0)
  box x {
    // here is layer -1
    // (x: int at -1)
    x
  }
}
</code></pre>
<p>The sequence <code>x1, ..., xn</code> can be empty. Thus, below is also a valid term:</p>
<pre><code class="language-neut">define box-unit(): meta unit {
  // here is layer 0
  box {
    // here is layer -1
    Unit
  }
}
</code></pre>
<p>On the other hand, below isn't a valid term:</p>
<pre><code class="language-neut">define some-function(x: bool): meta bool {
  // here is layer 0
  box {
    // here is at layer -1
    not(x)
  }
}
</code></pre>
<p>This is because the variable <code>x</code> is defined at layer 0 but used at layer -1.</p>
<h2 id="-elimination-extracting-values-from-boxes"><a class="header" href="#-elimination-extracting-values-from-boxes">□-elimination: Extracting Values from Boxes</a></h2>
<p>We can extract values from a box using <code>letbox</code>.</p>
<h3 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h3>
<p>The syntax of <code>letbox</code> is as follows:</p>
<pre><code class="language-neut">letbox x on y1, ..., ym =
  e1
in
e2
</code></pre>
<p>Or, with a bit verbose comments on layers and types:</p>
<pre><code class="language-neut">// here is layer n
// - y1: a1 @ n
// - ...
// - ym: am @ n
letbox x on y1, ..., ym =
  // here is layer (n+1)
  // - y1: &amp;a1 @ (n+1)
  // - ...
  // - ym: &amp;am @ (n+1)
  e1
in
// here is layer n
// - y1: a1 @ n
// - ...
// - ym: am @ n
e2
</code></pre>
<p>Given a boxed term <code>e1: meta a</code>, <code>letbox</code> binds it to <code>x: a</code>, and executes <code>e2</code>.</p>
<h3 id="semantics-1"><a class="header" href="#semantics-1">Semantics</a></h3>
<p>The operational semantics of <code>letbox</code> is as follows:</p>
<pre><code class="language-neut">letbox x on y1, ..., ym = e1 in
e2

↓

// pseudo-code
let y1 = cast(from=a1, to=&amp;a1, y1) in
...
let ym = cast(from=am, to=&amp;am, ym) in
let x = e1 in
let y1 = cast(from=&amp;a1, to=a1, y1) in
...
let ym = cast(from=&amp;am, to=am, ym) in
e2
</code></pre>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Let's see some examples. Below is a simple example of <code>letbox</code>:</p>
<pre><code class="language-neut">define use-letbox(): bool {
  let x = True in
  // here is layer 0
  letbox value =
    // here is layer 1
    box {
      // here is layer 0
      x
    }
  in
  // here is layer 0
  value
}
</code></pre>
<p>A bit more complex example:</p>
<pre><code class="language-neut">// helper function
define from-noema(x: &amp;bool): meta bool {
  box x {
    x
  }
}

define use-letbox(): bool {
  let x = True in
  let y = True in
  // here is layer 0
  // - x: bool @ 0
  // - y: bool @ 0
  letbox value on x =
    // here is layer 1
    // - x: &amp;bool @ 1
    // - y:  bool @ 0
    from-noema(x)
  in
  value
}
</code></pre>
<p>Below isn't a well-layered term:</p>
<pre><code class="language-neut">define use-letbox(x: meta bool): bool {
  // here is layer 0
  letbox value =
    // here is layer 1
    x // ← error: the layer of `x` is 0 but used at layer 1
  in
  x
}
</code></pre>
<h2 id="combination-of-box-and-letbox"><a class="header" href="#combination-of-box-and-letbox">Combination of <code>box</code> and <code>letbox</code></a></h2>
<p>Let's see how <code>box</code> and <code>letbox</code> work in harmony with each other.</p>
<h3 id="the-axiom-k-in-neut"><a class="header" href="#the-axiom-k-in-neut">The Axiom K in Neut</a></h3>
<p>We can prove the axiom K in the literature using <code>box</code> and <code>letbox</code>:</p>
<pre><code class="language-neut">// Axiom K: □(a -&gt; b) -&gt; □a -&gt; □b
define axiom-K&lt;a, b&gt;(f: meta (a) -&gt; b, x: meta a): meta b {
  box {
    letbox f' = f in
    letbox x' = x in
    f'(x')
  }
}
</code></pre>
<p>In this sense, the <code>meta</code> is a necessity operator that satisfies the axiom K.</p>
<div class="info-block">
<p>Don't confuse <code>meta (a) -&gt; b</code> with <code>(meta a) -&gt; b</code>.</p>
</div>
<h3 id="creating-and-embodying-a-noema"><a class="header" href="#creating-and-embodying-a-noema">Creating and Embodying a Noema</a></h3>
<p>The following code creates a noema using <code>letbox</code> and embodies it using <code>box</code>:</p>
<pre><code class="language-neut">define test-embody(): unit {
  let x: int = 1 in
  letbox result on x = // ← creates a noema
    box x { // ← embodies a noema
      add-int(x, 2)
    }
  in
  print-int(result) // → &quot;3&quot;
}
</code></pre>
<h3 id="borrowing-a-list"><a class="header" href="#borrowing-a-list">Borrowing a List</a></h3>
<p>Let's take a look at a more &quot;real-world&quot; example (It's funny to say &quot;real-world&quot; when talking about modality). Suppose that we have the following function:</p>
<pre><code class="language-neut">// returns `True` if and only if the input `xs` is empty.
is-empty: (xs: &amp;list(int)) -&gt; bool
</code></pre>
<p>You can use this function via <code>box</code> and <code>letbox</code>:</p>
<pre><code class="language-neut">define borrow-and-check-if-empty(): unit {
  let xs: list(int) = [1, 2, 3] in
  // layer 0
  // (xs: list(int) @ 0)
  letbox result on xs =
    // layer 1
    // (xs: &amp;list(int) @ 1)
    let b = is-empty(xs) in // ← using the borrowed `xs`
    if b {
      box {True}
    } else {
      box {False}
    }
  in
  // layer 0
  // (xs: list(int) @ 0)
  if result {
    print(&quot;xs is empty\n&quot;)
  } else {
    print(&quot;xs is not empty\n&quot;)
  }
}
</code></pre>
<p>In the above example, the variable <code>xs: list(int)</code> is turned into a noema by <code>letbox</code>, and then used by <code>is-empty</code>. Since <code>xs</code> is a noema inside the <code>letbox</code>, the <code>is-empty</code> doesn't have to consume the list <code>xs</code>.</p>
<h2 id="quote-a-shorthand-for-boxes"><a class="header" href="#quote-a-shorthand-for-boxes">Quote: A Shorthand for Boxes</a></h2>
<p>As in above, we can turn a <code>bool</code> into <code>meta bool</code> by doing something like this:</p>
<pre><code class="language-neut">define wrap-bool(b: bool): meta bool {
  if b {
    box {True}
  } else {
    box {False}
  }
}
</code></pre>
<p>You might find it a bit wordy. Indeed, this translation can be mechanically done on certain &quot;simple&quot; types. For example, we can do the same to <code>either(bool, unit)</code>:</p>
<pre><code class="language-neut">define wrap-either(x: either(bool, unit)): meta either(bool, unit) {
  match x {
  | Left(b) =&gt;
    if b {
      box {Left(True)}
    } else {
      box {Left(False)}
    }
  | Right(u) =&gt;
    box {Right(Unit)}
  }
}
</code></pre>
<p>We just have to decompose values and reconstruct them with <code>box</code> added.</p>
<p>Neut has a syntactic construct <code>quote</code> that bypasses these manual translations. Using <code>quote</code>, the above two functions can be rewritten into the following functions:</p>
<pre><code class="language-neut">define wrap-bool(b: bool): meta bool {
  quote {b}
}

define wrap-either(x: either(bool, unit)): meta either(bool, unit) {
  quote {x}
}
</code></pre>
<p>The example of <code>is-empty</code> can now be rewritten as follows:</p>
<pre><code class="language-neut">define foo(): unit {
  let xs: list(int) = [1, 2, 3] in
  // layer 0
  // (xs: list(int) @ 0)
  letbox result on xs =
    // layer 1
    // (xs: &amp;list(int) @ 1)
    quote {is-empty(xs)}
  in
  // layer 0
  // (xs: list(int) @ 0)
  if result {
    print(&quot;xs is empty\n&quot;)
  } else {
    print(&quot;xs is not empty\n&quot;)
  }
}
</code></pre>
<p><code>quote</code> cannot be used against types that might contain types of the form <code>&amp;a</code> or <code>(a) -&gt; b</code>. For example, <code>quote</code> cannot be applied against values of the following types:</p>
<ul>
<li><code>&amp;list(int)</code></li>
<li><code>(int) -&gt; bool</code></li>
<li><code>either(bool, &amp;list(int))</code></li>
<li><code>either(bool, (int) -&gt; bool)</code></li>
</ul>
<p><code>quote</code> is after all just a shorthand.</p>
<h2 id="-elimination-t-unboxing-within-the-current-layer"><a class="header" href="#-elimination-t-unboxing-within-the-current-layer">□-elimination-T: Unboxing within the Current Layer</a></h2>
<p>Remember the example of <code>is-empty</code>:</p>
<pre><code class="language-neut">define borrow-and-check-if-empty(): unit {
  let xs: list(int) = [1, 2, 3] in
  letbox result on xs =
    // here is layer 1
    let b = is-empty(xs) in
    (..)
  in
  (..)
}
</code></pre>
<p>Although the above term is valid, the term obtained by parameterizing <code>is-empty</code> is not valid:</p>
<pre><code class="language-neut">define borrow-and-check-if-empty(is-empty: (&amp;list(int)) -&gt; bool): unit {
  let xs: list(int) = [1, 2, 3] in
  letbox result on xs =
    // here is layer 1
    let b = is-empty(xs) in // ← error
    (..)
  in
  (..)
}
</code></pre>
<p>This is because the variable <code>is-empty</code> is defined at layer 0 but used at layer 1.</p>
<p><code>letbox-T</code> is the loophole for such situations.</p>
<h3 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h3>
<p>The syntax of <code>letbox-T</code> is as follows:</p>
<pre><code class="language-neut">// here is layer n
// (y1: a1): a variable at layer n
// ...
// (ym: am): a variable at layer n
letbox-T x on y1, ..., yn =
  // here is layer n
  // (y1: &amp;a1): a variable at layer n
  // ...
  // (ym: &amp;am): a variable at layer n
  e1
in
// here is layer n
// (y1: a1): a variable at layer n
// ...
// (ym: am): a variable at layer n
e2
</code></pre>
<p>That is, <code>letbox-T</code> is the same as <code>letbox</code> except that it doesn't change the layer structure.</p>
<h3 id="semantics-2"><a class="header" href="#semantics-2">Semantics</a></h3>
<p>The operational semantics of <code>letbox-T</code> is again the same as <code>letbox</code>:</p>
<pre><code class="language-neut">letbox-T x on y1, ..., ym = e1 in
e2

↓

let y1 = unsafe-cast(a1, &amp;a1, y1) in
...
let ym = unsafe-cast(am, &amp;am, ym) in
let x = e1 in
let y1 = unsafe-cast(&amp;a1, a1, y1) in
...
let ym = unsafe-cast(&amp;am, am, ym) in
e2
</code></pre>
<h3 id="example-parameterizing-a-callback"><a class="header" href="#example-parameterizing-a-callback">Example: Parameterizing a Callback</a></h3>
<p>Using <code>letbox-T</code>, we can parameterize <code>is-empty</code> as follows:</p>
<pre><code class="language-neut">define borrow-and-check-if-empty(is-empty: (&amp;list(int)) -&gt; bool): unit {
  let xs: list(int) = [1, 2, 3] in
  // layer 0
  // (xs: list(int) @ 0)
  // (is-empty: &amp;list(int) -&gt; bool @ 0)
  letbox-T result on xs =
    // layer 0
    // (xs: &amp;list(int) @ 0)
    // (is-empty: &amp;list(int) -&gt; bool @ 0)
    let b = is-empty(xs) in
    (..)
  in
  // layer 0
  // (xs: list(int) @ 0)
  // (is-empty: &amp;list(int) -&gt; bool @ 0)
  (..)
}
</code></pre>
<p>Note that the body of <code>letbox-T</code> in the example above is not layer 1 but layer 0.</p>
<h3 id="example-the-axiom-t-in-neut"><a class="header" href="#example-the-axiom-t-in-neut">Example: The Axiom T in Neut</a></h3>
<p>You can prove the axiom T by using <code>letbox-T</code>:</p>
<pre><code class="language-neut">// Axiom T: □a -&gt; a
define axiom-T&lt;a&gt;(x: meta a): a {
  letbox-T tmp = x in
  tmp
}
</code></pre>
<p>Note that the following is not well-layered:</p>
<pre><code class="language-neut">define axiom-T&lt;a&gt;(x: meta a): a {
  letbox tmp = x in
  tmp
}
</code></pre>
<p>since the variable <code>x</code> is defined at layer 0 but used at layer 1.</p>
<p>In this sense, the <code>meta</code> is a necessity operator that satisfies the axiom T.</p>
<p>(I know this is a bit too informal, but anyway)</p>
<h3 id="example-desugaring-let-on-using-the-t-necessity"><a class="header" href="#example-desugaring-let-on-using-the-t-necessity">Example: Desugaring let-on Using the T-necessity</a></h3>
<p>Now we can desugar <code>let-on</code> as follows:</p>
<pre><code class="language-neut">let x on y, z = e1 in
e2

↓

letbox-T x on y, z = quote {e1} in
e2
</code></pre>
<p>and this is why the type of <code>e1</code> must be restricted to some extent. Now we can see that those restrictions come from <code>quote</code>.</p>
<h2 id="layer-closedness-of-functions"><a class="header" href="#layer-closedness-of-functions">Layer Closedness of Functions</a></h2>
<p>There's one last condition that we must require: every free variable in a <code>function</code> must be at the layer of <code>function</code>. For example, the following is not a valid term:</p>
<pre><code class="language-neut">define use-function(x: meta int): meta () -&gt; int {
  // layer 0
  let x = 10 in
  box {
    // layer -1
    function () {
      letbox value = x in
      value
    }
  }
}
</code></pre>
<p>This is because the function is at layer -1, but the free variable <code>x</code> is at layer 0.</p>
<p>If it were not for this condition, the following would be well-typed and well-layered:</p>
<pre><code class="language-neut">define joker(): () -&gt; unit {
  // layer 0
  let xs: list(int) = [1, 2, 3] in
  letbox f on xs =
    // layer 1
    // xs: at 1
    box {
      // layer 0
      // 💫
      function () {
        letbox k =
          // 1
          let len =
            // using xs@1 in function@0
            length(xs)
          in
          box {Unit}
        in
        Unit
      }
    }
  in
  f
}
</code></pre>
<p>The inner function (💫), which depends on <code>xs: &amp;list(int)</code>, is bound to <code>f</code> after evaluating the outer <code>letbox</code>. Thus, we would be able to cause the dreaded use-after-free by deallocating <code>xs</code> and then calling the function <code>f</code>.</p>
<h2 id="what-youve-learned-here-3"><a class="header" href="#what-youve-learned-here-3">What You've Learned Here</a></h2>
<ul>
<li>Layer structures of <code>box</code>, <code>letbox</code>, <code>letbox-T</code>, and <code>function</code></li>
<li>Using <code>box</code> or <code>quote</code> to create terms of type <code>meta {..}</code></li>
<li>Using <code>letbox</code> or <code>letbox-T</code> to use terms of type <code>meta {..}</code></li>
<li>Decomposition of <code>let-on</code> into <code>letbox-T</code> and <code>quote</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-reference"><a class="header" href="#language-reference">Language Reference</a></h1>
<p>In this chapter, you should be able to find all the details of Neut.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>The command <code>neut</code> has subcommands like <code>neut build</code>, <code>neut get</code>, etc. This section describes those subcommands.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="commands.html#common-notes">Common Notes</a></li>
<li><a href="commands.html#neut-build">neut build</a></li>
<li><a href="commands.html#neut-check">neut check</a></li>
<li><a href="commands.html#neut-clean">neut clean</a></li>
<li><a href="commands.html#neut-archive">neut archive</a></li>
<li><a href="commands.html#neut-create">neut create</a></li>
<li><a href="commands.html#neut-get">neut get</a></li>
<li><a href="commands.html#neut-format-source">neut format-source</a></li>
<li><a href="commands.html#neut-format-ens">neut format-ens</a></li>
<li><a href="commands.html#neut-zen">neut zen</a></li>
<li><a href="commands.html#neut-lsp">neut lsp</a></li>
<li><a href="commands.html#neut-version">neut version</a></li>
</ul>
<h2 id="common-notes"><a class="header" href="#common-notes">Common Notes</a></h2>
<h3 id="subcommands-and-modules"><a class="header" href="#subcommands-and-modules">Subcommands and Modules</a></h3>
<p>Most of the subcommands of <code>neut</code> must be executed inside a module. If you execute such a subcommand outside a module, the command will emit an error like the one below:</p>
<pre><code class="language-sh">neut build foo
#=&gt; Error: Couldn't find a module file (Context: /Users/foo/Desktop)
</code></pre>
<p>Only the following subcommands can be used outside a module:</p>
<ul>
<li><code>neut create</code></li>
<li><code>neut version</code></li>
</ul>
<h3 id="shared-command-line-options"><a class="header" href="#shared-command-line-options">Shared command line options:</a></h3>
<p>Some subcommands share command line options. The list of them is as follows:</p>
<ul>
<li><code>--no-color</code> can be used to turn off ANSI colors</li>
</ul>
<h2 id="neut-build"><a class="header" href="#neut-build"><code>neut build</code></a></h2>
<p><code>neut build</code> builds the current module and creates executables. It also creates cache files of the source files for faster compilation.</p>
<p><code>neut build TARGET</code> builds the target <code>TARGET</code> defined in <code>module.ens</code>. For example, suppose that the <code>module.ens</code> of a module contains the following section:</p>
<pre><code class="language-ens">{
  // ..
  target {
    foo {
      main &quot;foo.nt&quot;,
    },
    bar {
      main &quot;item/bar.nt&quot;,
    },
  },
  // ..
}
</code></pre>
<p>In this case, running <code>neut build foo</code> creates the executable <code>foo</code> by building the current module, using the <code>main</code> in <code>foo.nt</code> as the entry point.</p>
<p>The resulting binaries are put inside the module's build directory. You might want to use the option <code>--install</code> to copy those binaries.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-sh"># creates a sample project
neut create hello
cd hello

# build and run
neut build hello --execute # =&gt; &quot;Hello, world!&quot;

# build the module, copy the resulting binary, and execute the binary
neut build hello --install ./bin
./bin/hello #=&gt; &quot;Hello, world!&quot;
</code></pre>
<h3 id="--execute"><a class="header" href="#--execute"><code>--execute</code></a></h3>
<p>If you pass <code>--execute</code> to <code>neut build</code>, the resulting binaries are executed after the build.</p>
<h3 id="--install-dir"><a class="header" href="#--install-dir"><code>--install DIR</code></a></h3>
<p>If you pass <code>--install DIR</code> to <code>neut build</code>, the resulting binaries are copied to the specified directory.</p>
<h3 id="--skip-link"><a class="header" href="#--skip-link"><code>--skip-link</code></a></h3>
<p>By default, <code>neut build</code> builds all the source files into object files and then links them all to create an executable. You can pass <code>--skip-link</code> to <code>neut build</code> to skip the last linking phase.</p>
<h3 id="--emit"><a class="header" href="#--emit"><code>--emit</code></a></h3>
<p>You can emit LLVM IR by passing <code>--emit llvm</code> to <code>neut build</code>. In this case, you must also pass <code>--skip-link</code>.</p>
<h3 id="--mode"><a class="header" href="#--mode"><code>--mode</code></a></h3>
<p>You can pass <code>--mode {develop,release}</code> like the below:</p>
<pre><code class="language-sh">neut build my-app --mode release
</code></pre>
<p>If you don't specify <code>--mode</code>, the mode defaults to <code>develop</code>.</p>
<p>The value passed here can be obtained from source files by using <code>introspect</code>:</p>
<pre><code class="language-neut">define foo(): unit {
  introspect build-mode {
  | release =&gt;
    // ..
  | develop =&gt;
    // ..
  }
}
</code></pre>
<h3 id="--end-of-entry"><a class="header" href="#--end-of-entry"><code>--end-of-entry</code></a></h3>
<p><code>--end-of-entry ANY_STRING</code> can be used to add separators between compiler diagnostics. This feature is for linter wrappers like flycheck.</p>
<p>For example, suppose we have this ill-typed program:</p>
<pre><code class="language-neut">define main(): int {
  type
}
</code></pre>
<p>When running <code>neut build TARGET</code>, the compiler reports errors like the below:</p>
<pre><code class="language-text">/path/to/sample/source/hey.nt:1:8
Error: Expected:
         () -&gt; unit
       Found:
         () -&gt; int64
/path/to/sample/source/hey.nt:2:3
Error: Expected:
         int64
       Found:
         type
</code></pre>
<p>On the other hand, when running <code>neut build TARGET --end-of-entry EOE</code>, the text <code>EOE</code> is inserted after each entry:</p>
<pre><code class="language-text">/path/to/sample/source/hey.nt:1:8
Error: Expected:
         () -&gt; unit
       Found:
         () -&gt; int64
EOE
/path/to/sample/source/hey.nt:2:3
Error: Expected:
         int64
       Found:
         type
EOE
</code></pre>
<p>These can be used to parse entries.</p>
<h2 id="neut-check"><a class="header" href="#neut-check"><code>neut check</code></a></h2>
<p><code>neut check</code> type-checks all the files in the current module. It also creates cache files of the source files for faster compilation.</p>
<h3 id="--no-padding"><a class="header" href="#--no-padding"><code>--no-padding</code></a></h3>
<p>The compiler prints diagnostics without padding spaces if <code>--no-padding</code> is set.</p>
<p>Without <code>--no-padding</code>:</p>
<pre><code class="language-text">/path/to/sample/source/hey.nt:1:8
Error: Expected:
         () -&gt; unit
       Found:
         () -&gt; int64
/path/to/sample/source/hey.nt:2:3
Error: Expected:
         int64
       Found:
         type
</code></pre>
<p>With <code>--no-padding</code>:</p>
<pre><code class="language-text">/Users/vekatze/Desktop/hey/source/hey.nt:1:8
Error: Expected:
  () -&gt; unit
Found:
  () -&gt; int64
/Users/vekatze/Desktop/hey/source/hey.nt:2:3
Error: Expected:
  int64
Found:
  type
</code></pre>
<p>This option is for linter wrappers like flycheck.</p>
<h3 id="--end-of-entry-1"><a class="header" href="#--end-of-entry-1"><code>--end-of-entry</code></a></h3>
<p>The same as the one of <code>neut build</code>.</p>
<h2 id="neut-clean"><a class="header" href="#neut-clean"><code>neut clean</code></a></h2>
<p><code>neut clean</code> removes the cache files in the current module's <code>cache</code> directory.</p>
<p>More specifically, this command removes the following directory in the current module:</p>
<pre><code class="language-text">(cache-directory)/build/(platform)/(compiler-version)/
</code></pre>
<p>An example of a removed directory:</p>
<pre><code class="language-text">cache/build/arm64-darwin/compiler-0.8.0/
</code></pre>
<h2 id="neut-archive"><a class="header" href="#neut-archive"><code>neut archive</code></a></h2>
<p><code>neut archive VERSION</code> creates a module tarball that can be used by <code>neut get</code>.</p>
<h3 id="notes-on-versions"><a class="header" href="#notes-on-versions">Notes on Versions</a></h3>
<p><code>VERSION</code> must be <code>X1-X2-..-Xn</code>, where all the integers are non-negative. For example, the following are valid versions:</p>
<ul>
<li><code>1-0</code></li>
<li><code>0-1-0</code></li>
<li><code>2-1-3</code></li>
<li><code>0-0-0-3</code></li>
</ul>
<p>When running <code>neut archive VERSION</code>, this command searches the archive directory to get all the compatible older versions. For example, suppose the archive directory contains the following files:</p>
<ul>
<li><code>1-0.tar.zst</code></li>
<li><code>1-1.tar.zst</code></li>
<li><code>2-0.tar.zst</code></li>
<li><code>2-1.tar.zst</code></li>
</ul>
<p>In this case, the command <code>neut archive 2-2</code> searches the <code>archive</code> directory and gets <code>2-0</code> and <code>2-1</code> as the older compatible versions of <code>2-2</code>. Here, these &quot;older&quot; versions are determined according to <a href="https://semver.org/">Semantic Versioning</a>.</p>
<p>This command then does the following:</p>
<ol>
<li>Computes all the digests of these older compatible tarballs</li>
<li>Creates a new <code>module.ens</code> that contains the list of the older digests</li>
<li>Packs the ens file and the other required files to create a tarball <code>2-2.tar.zst</code></li>
</ol>
<p>This digest information inside <code>module.ens</code> of <code>2-2.tar.zst</code> should appear like the below:</p>
<pre><code class="language-ens">{
  target {..},
  dependency {..},
  antecedent [
    &quot;Bp8RulJ-XGTL9Eovre0yQupJpeS3lGNk8Q6QQYua7ag&quot;, // ← digest of 2-0.tar.zst
    &quot;zptXghmyD5druBl8kx2Qrei6O6fDsKCA7z2KoHp1aqA&quot;, // ← digest of 2-1.tar.zst
  ],
}
</code></pre>
<p>This information is then used when resolving dependencies.</p>
<p>You can extract a resulting tarball to see that <code>antecedent</code> information is indeed there.</p>
<div class="info-block">
<p>The <code>module.ens</code> in your module isn't modified by <code>archive</code>. This subcommand creates a new <code>module.ens</code> and put it into the tarball.</p>
</div>
<h3 id="using-the-newest-compatible-version"><a class="header" href="#using-the-newest-compatible-version">Using the Newest Compatible Version</a></h3>
<p>Consider the following dependency relation:</p>
<ul>
<li>Module <code>A</code> depends on <code>B</code> and <code>C</code>.</li>
<li>Module <code>B</code> depends on <code>D (version 1.1)</code>.</li>
<li>Module <code>C</code> depends on <code>D (version 1.2)</code>.</li>
</ul>
<pre><code class="language-text">A ──&gt; B ──&gt; D (1.1)
│
└───&gt; C ──&gt; D (1.2)
</code></pre>
<p>Thanks to the <code>antecedent</code> information inside <code>D (1.2)</code>, the compiler can detect that <code>D (1.2)</code> is a newer compatible module of <code>D (1.1)</code>. The compiler utilizes this knowledge to rewrite the above relation into:</p>
<pre><code class="language-text">A ──&gt; B ──┐
│         │
└───&gt; C ──┴──&gt; D (1.2)
</code></pre>
<p>The compiler always uses the newest compatible modules in the dependency relation by this procedure.</p>
<div class="info-block">
<p>This rewriting won't work if the minor &quot;compatible&quot; version <code>D (1.2)</code> isn't compatible with <code>D (1.1)</code>. This incompatibility is a bug of the library <code>D (1.2)</code> and should be fixed by the module author.</p>
</div>
<h3 id="utilizing-the-compatibility-relation"><a class="header" href="#utilizing-the-compatibility-relation">Utilizing the Compatibility Relation</a></h3>
<p>As an exercise, suppose the following:</p>
<ol>
<li>Serious bugs were discovered in <code>D (1.1)</code> and <code>D (1.2)</code></li>
<li>The grave-look author of <code>D</code> released a bug-fix release <code>D (1.3)</code> in a hurry</li>
<li>The happy authors of <code>B</code> and <code>C</code> are on a honeymoon vacation in Hawaii</li>
</ol>
<p>In this case, we don't have to wait for the authors of <code>B</code> and <code>C</code> to update their dependencies. Instead, we can just add <code>D (1.3)</code> to our module's dependency:</p>
<pre><code class="language-text">A ──&gt; B ──┐
│         │
├───&gt; C ──┴──&gt; D (1.2)
│
└────────────&gt; D (1.3)
</code></pre>
<p>Then, the compiler automatically rewrites the above relation into:</p>
<pre><code class="language-text">A ──&gt; B ───┐
│          │
├───&gt; C ───┤
│          │
└──────────┴──&gt; D (1.3)
</code></pre>
<p>So we don't have to rain on their happy parade in Waikiki Beach.</p>
<h2 id="neut-create"><a class="header" href="#neut-create"><code>neut create</code></a></h2>
<p><code>neut create NAME</code> creates a directory <code>./NAME/</code> and adds files there to start a new project.</p>
<h2 id="neut-get"><a class="header" href="#neut-get"><code>neut get</code></a></h2>
<p><code>neut get ALIAS URL</code> fetches and builds external modules specified by <code>URL</code> and adds it to the current module as a dependency under the name <code>ALIAS</code>.</p>
<pre><code class="language-sh">neut get some-name https://github.com/USER_NAME/REPO_NAME/raw/main/archive/0-1.tar.zst
</code></pre>
<p>Here, the <code>URL</code> must be the URL of an archive that was created by <code>neut archive</code>.</p>
<p>After executing <code>neut get</code>, the information of the new module is saved to <code>module.ens</code>:</p>
<pre><code class="language-ens">{
  target {
    // ..
  },
  dependency {
    // ..
    // 🌟 (something like this is added automatically)
    some-name {
      digest &quot;xNmQu6It81lGBy1sKvk5_jE4Qt8w8KgkVgGj0RBbbrk&quot;,
      mirror [
        &quot;https://github.com/USER_NAME/REPO_NAME/raw/main/archive/0-1.tar.zst&quot;,
      ],
    },
    // ..
  },
}
</code></pre>
<p>The <code>digest</code> is the base64url-encoded checksum of the tarball.</p>
<p>The <code>mirror</code> is a list of URLs that can be used to obtain the tarball.</p>
<div class="info-block">
<p>Modules in Neut are distinguished by their digests.</p>
</div>
<p><code>neut get</code> can be used to &quot;update&quot; dependencies. Suppose you specify an existing <code>ALIAS</code> when running <code>neut get ALIAS URL</code>. In this case, if the digest of the new tarball isn't the same as the existing one, the existing dependency in the ens file is replaced by the newer one. If the digest is the same as the existing one, the <code>URL</code> is added to the list <code>mirror</code>.</p>
<p>You can remove a dependency in the ens file to &quot;remove&quot; the module from your module.</p>
<p>You can import dependencies from source files. See the notes on <code>import</code> in <a href="./statements.html#import">Statements</a> for information on how to use definitions in external dependencies.</p>
<h2 id="neut-format-source"><a class="header" href="#neut-format-source"><code>neut format-source</code></a></h2>
<p><code>neut format-source path/to/source/file.nt</code> formats specified source file and outputs the result to stdout.</p>
<h3 id="--in-place"><a class="header" href="#--in-place"><code>--in-place</code></a></h3>
<p>When the option <code>--in-place</code> is set, <code>format-source</code> performs in-place update.</p>
<h3 id="--minimize-imports"><a class="header" href="#--minimize-imports"><code>--minimize-imports</code></a></h3>
<p>When the option <code>--minimize-imports</code> is set, <code>format-source</code> removes all the unused items in <code>import {..}</code>.</p>
<h2 id="neut-format-ens"><a class="header" href="#neut-format-ens"><code>neut format-ens</code></a></h2>
<p><code>neut format-ens path/to/source/file.ens</code> formats specified ens file and outputs the result to stdout.</p>
<p>You can also pass <code>-</code> to receive input from stdin:</p>
<pre><code class="language-sh">cat module.ens | neut format-ens -
</code></pre>
<h3 id="--in-place-1"><a class="header" href="#--in-place-1"><code>--in-place</code></a></h3>
<p>When the option <code>--in-place</code> is set, <code>format-source</code> performs in-place update.</p>
<h2 id="neut-zen"><a class="header" href="#neut-zen"><code>neut zen</code></a></h2>
<p><code>neut zen path/to/source/file.nt</code> builds and executes specified file as if it were an entry point.</p>
<p>The subcommand <code>zen</code> treats the function <code>zen</code> inside the given file as its entry point (that is, <code>main</code>).</p>
<p>Thus, the type of the function <code>zen</code> must be <code>() -&gt; unit</code>:</p>
<pre><code class="language-neut">define zen(): unit {
  print(&quot;hello, world!\n&quot;)
}
</code></pre>
<p>This command is intended to be used for rapid prototyping.</p>
<p>Please see <a href="./rapid-prototyping.html">Rapid Prototyping</a> to see <code>neut zen</code> in action.</p>
<h3 id="zen-experience"><a class="header" href="#zen-experience">Zen Experience</a></h3>
<p>Suppose that you created a new function deep inside your module.</p>
<p>You can technically create a test function for the function and check its behavior. Or modify the main function to call the new function just to see its behavior.</p>
<p>It might be, however, a bit cumbersome. We'd love to achieve rapid try-and-error cycles in certain circumstances.</p>
<p>You can use the command <code>zen</code> here. Suppose that a file <code>some-file.nt</code> contains a function <code>foo</code> that is defined as in the below:</p>
<pre><code class="language-neut">define foo(x: int): int {
  do-complex-calculation(x)
}
</code></pre>
<p>The behavior of <code>foo</code> can be inspected rapidly by defining a function named <code>zen</code> in the file:</p>
<pre><code class="language-neut">// the type of `zen` must be `() -&gt; unit`
define zen(): unit {
  print-int(foo(10))
}
</code></pre>
<p>Then, execute the following command:</p>
<pre><code class="language-sh">neut zen path/to/some-file.nt # =&gt; (the result of `foo(10)` is printed)
</code></pre>
<p>This can be done even if <code>some-file.nt</code> isn't an entrypoint of the module. You can think of functions named <code>zen</code> as alternative <code>main</code>s.</p>
<h2 id="neut-lsp"><a class="header" href="#neut-lsp"><code>neut lsp</code></a></h2>
<p><code>neut lsp</code> starts the LSP server. The LSP server has features like linting, jump to definition, etc. More specifically, the LSP server supports the following LSP capabilities:</p>
<ul>
<li><code>textDocument/didOpen</code> (lint on open)</li>
<li><code>textDocument/didSave</code> (lint on save)</li>
<li><code>textDocument/completion</code> (complete)</li>
<li><code>textDocument/definition</code> (jump to definition)</li>
<li><code>textDocument/documentHighlight</code> (highlight symbols)</li>
<li><code>textDocument/references</code> (find references)</li>
<li><code>textDocument/formatting</code> (format)</li>
<li><code>textDocument/hover</code> (show the type of a symbol)</li>
</ul>
<p>For more information, please see <a href="./lovely-lsp-showcase.html">Lovely LSP Showcase</a> and <a href="./editor-setup.html">Editor Setup</a>.</p>
<h2 id="neut-version"><a class="header" href="#neut-version"><code>neut version</code></a></h2>
<p><code>neut version</code> prints the version of the compiler.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-sh">neut version
#=&gt; X.Y.Z
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>A directory (including its all children) is a <em>module</em> if it contains a file named <code>module.ens</code>.</p>
<p>Below is the list of configurations of <code>module.ens</code>.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="modules.html#target">target</a></li>
<li><a href="modules.html#dependency">dependency</a></li>
<li><a href="modules.html#archive">archive</a></li>
<li><a href="modules.html#build">build</a></li>
<li><a href="modules.html#source">source</a></li>
<li><a href="modules.html#prefix">prefix</a></li>
<li><a href="modules.html#foreign">foreign</a></li>
<li><a href="modules.html#static">static</a></li>
<li><a href="modules.html#preset">preset</a></li>
<li><a href="modules.html#inline-limit">inline-limit</a></li>
<li><a href="modules.html#antecedent">antecedent</a></li>
</ul>
<h2 id="target"><a class="header" href="#target"><code>target</code></a></h2>
<p>The field <code>target</code> defines the entry points of a module. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  target {
    TARGET-1 {
      main &quot;path/to/source/file-1.nt&quot;
    },
    // ..
    TARGET-N {
      main &quot;path/to/source/file-n.nt&quot;
    },
  },
  // ..
}
</code></pre>
<p>Suppose that your module has the following <code>target</code> in <code>module.ens</code>:</p>
<pre><code class="language-ens">{
  // ..
  target {
    foo {
      main &quot;foo.nt&quot;,
    },
    bar {
      main &quot;item/whatever.nt&quot;
    },
  },
  // ..
}
</code></pre>
<p>In this case, your module has two targets: <code>foo</code> and <code>bar</code>. The entry point of <code>foo</code> is the <code>main</code> function in <code>(source-dir)/foo.nt</code>. The entry point of <code>bar</code> is the <code>main</code> function in <code>(source-dir)/item/whatever.nt</code>.</p>
<p>The names in <code>target</code> can be specified when running <code>neut build</code>. For example, given the above definition of <code>target</code>, you can run <code>neut build foo</code>.</p>
<p>The names of targets are also used as the names of executables. For example, if you run <code>neut build foo --install ./bin/</code>, an executable named <code>foo</code> will be created under the directory <code>./bin/</code>.</p>
<p>The field <code>target</code> is optional. The default value of <code>target</code> is <code>{}</code>.</p>
<h3 id="compile-option"><a class="header" href="#compile-option"><code>compile-option</code></a></h3>
<p>You can add <code>compile-option</code> to a target as follows:</p>
<pre><code class="language-ens">{
  target {
    foo {
      main &quot;foo.nt&quot;,
      // ↓ here
      compile-option [
        &quot;-g&quot;,
        &quot;-O0&quot;,
        &quot;-fsanitize=address&quot;,
        &quot;$SOME_ENV_VAR&quot;,
        &quot;$(some-command arg)&quot;,
      ],
    },
  },
}
</code></pre>
<p>The compiler passes the options specified here to <code>clang</code> when compiling LLVM IRs into object files.</p>
<p>In <code>compile-option</code>, you can use environment variables and shell interpolations.</p>
<p>The field <code>compile-option</code> is optional. The default value of <code>compile-option</code> is <code>[]</code>.</p>
<h3 id="link-option"><a class="header" href="#link-option"><code>link-option</code></a></h3>
<p>You can add <code>link-option</code> to a target as follows:</p>
<pre><code class="language-ens">{
  target {
    foo {
      main &quot;foo.nt&quot;,
      // ↓ here
      link-option [
        &quot;-g&quot;,
        &quot;-O0&quot;,
        &quot;$SOME_ENV_VAR&quot;,
        &quot;$(some-command)&quot;,
      ],
    },
  },
}
</code></pre>
<p>The compiler passes the options specified here to <code>clang</code> when linking object files.</p>
<p>In <code>link-option</code>, you can use environment variables and shell interpolations.</p>
<p>The field <code>link-option</code> is optional. The default value of <code>link-option</code> is <code>[]</code>.</p>
<h3 id="build-option"><a class="header" href="#build-option"><code>build-option</code></a></h3>
<p>You can add <code>build-option</code> to a target as follows:</p>
<pre><code class="language-ens">{
  target {
    foo {
      main &quot;foo.nt&quot;,
      // ↓ here
      build-option [
        &quot;$(pkg-config openssl --libs --cflags)&quot;,
        &quot;whatever&quot;,
      ],
    },
  },
}
</code></pre>
<p>Adding an element to <code>build-option</code> is the same as adding the element to both <code>compile-option</code> and <code>link-option</code>.</p>
<p>In <code>build-option</code>, you can use environment variables and shell interpolations.</p>
<p>The field <code>build-option</code> is optional. The default value of <code>build-option</code> is <code>[]</code>.</p>
<h2 id="dependency"><a class="header" href="#dependency"><code>dependency</code></a></h2>
<p>The field <code>dependency</code> defines the dependencies of a module. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  dependency {
    foo {
      digest &quot;(base64url-encoded sha256 checksum)&quot;,
      mirror [
        &quot;URL-1&quot;,
        // ..
        &quot;URL-N&quot;,
      ],
      enable-preset &lt;true | false&gt;, // ← optional field
    },
    // ..
    bar { .. },
  },
  // ..
}
</code></pre>
<p>An example of <code>dependency</code>:</p>
<pre><code class="language-ens">{
  // ..
  dependency {
    core {
      digest &quot;ub3MUXVac9F1rebIhl_Crm2_GJ7PzCAekgp8aYH3-mo&quot;,
      mirror [
        &quot;https://github.com/vekatze/neut-core/raw/main/archive/0-38.tar.zst&quot;,
      ],
      enable-preset true,
    },
    some-package {
      digest &quot;F_ST8PtL9dLCDWVZ4GpuS7sviUU0_-TUz2s6iw-86KU&quot;,
      mirror [
        &quot;https://example.com/foobarbuz/packages/22-3.tar.zst&quot;,
      ],
    },
  },
    // ..
}
</code></pre>
<p>The field <code>digest</code> specifies the checksum of the tarball of the dependency. The digest is a Base64URL-encoded SHA256 checksum of the tarball. This digest is the &quot;real&quot; name of this dependency, and used as an identifier.</p>
<p>The field <code>mirror</code> specifies a list of URLs from which the compiler can fetch the tarball. When running <code>neut get</code>, the compiler will try to get the tarball if necessary, using this list from the beginning to the end.</p>
<p>The optional field <code>enable-preset</code> specifies whether to import <code>preset</code>s automatically, as in &quot;prelude&quot; in other languages. This field should only be used (and set to be true) with the core library. For more information, see the explanation of <code>preset</code> in this section.</p>
<p>The field <code>dependency</code> is optional. The default value of <code>dependency</code> is <code>{}</code>.</p>
<h2 id="archive"><a class="header" href="#archive"><code>archive</code></a></h2>
<p>The field <code>archive</code> defines the path of the directory into which the subcommand <code>neut archive</code> store tarballs. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  archive &quot;my-archive&quot;,
  // ..
}
</code></pre>
<p>The field <code>archive</code> is optional. The default value of <code>archive</code> is <code>./archive/</code>.</p>
<h2 id="cache"><a class="header" href="#cache"><code>cache</code></a></h2>
<p>The field <code>cache</code> defines the path of the directory to store object files, executables, dependencies, etc. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  cache &quot;.cache&quot;,
  // ..
}
</code></pre>
<p>The field <code>cache</code> is optional. The default value of <code>cache</code> is <code>./cache/</code>.</p>
<h2 id="source"><a class="header" href="#source"><code>source</code></a></h2>
<p>The field <code>source</code> defines the path of the directory to store source files. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  source &quot;.&quot;,
  // ..
}
</code></pre>
<p>The field <code>source</code> is optional. The default value of <code>source</code> is <code>./source/</code>.</p>
<h2 id="prefix"><a class="header" href="#prefix"><code>prefix</code></a></h2>
<p>The field <code>prefix</code> defines the aliases of source files. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  prefix {
    Foo &quot;this.foo&quot;,
    // ..
    Bar &quot;this.item.bar&quot;,
  },
  // ..
}
</code></pre>
<p>Each field in <code>prefix</code> specifies an alias of the specified source file. For example, given the definition above, the code</p>
<pre><code class="language-neut">import {
  this.foo,
  this.item.bar {some-func},
}
</code></pre>
<p>can be rewritten into the following:</p>
<pre><code class="language-neut">import {
  Foo,
  Bar {some-func},
}
</code></pre>
<p>The prefixes specified in a <code>module.ens</code> of a module can be used only in the module.</p>
<p>The field <code>prefix</code> is optional. The default value of <code>prefix</code> is <code>{}</code>.</p>
<h2 id="foreign"><a class="header" href="#foreign"><code>foreign</code></a></h2>
<p>The field <code>foreign</code> defines a way to compile external source files. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  foreign {
    input [
      &quot;source/foo.c&quot;,
      &quot;source/bar.c&quot;,
    ],
    output [
      &quot;foo.o&quot;,
      &quot;bar.o&quot;
    ],
    script [
      &quot;{{clang}} -c -flto=thin -O2 source/foo.c -o {{foreign}}/foo.o&quot;,
      &quot;{{clang}} -c -flto=thin -O2 source/bar.c -o {{foreign}}/bar.o&quot;,
    ]
  }
}
</code></pre>
<h3 id="input"><a class="header" href="#input"><code>input</code></a></h3>
<p>The field <code>input</code> specifies the list of external source files. The paths are relative to the root of the module.</p>
<p>When running <code>neut archive</code>, the compiler adds all the <code>input</code> files to the resulting tarballs.</p>
<h3 id="output"><a class="header" href="#output"><code>output</code></a></h3>
<p>The field <code>output</code> specifies the resulting files of foreign source files. The paths are relative to a directory named <em>foreign directory</em>. You can find a foreign directory in the build directory.</p>
<p>When running <code>neut build</code>, the compiler links all the <code>output</code> files in the foreign directory (in addition to Neut's &quot;domestic&quot; object files).</p>
<h3 id="script"><a class="header" href="#script"><code>script</code></a></h3>
<p>The field <code>script</code> specifies how to compile external source files. When running <code>neut build</code>, the compiler executes the specified commands immediately after resolving all the <code>import</code>s.</p>
<p>In the field <code>script</code>, you can use the following placeholders:</p>
<ul>
<li><code>{{clang}}</code>: The <code>clang</code> used by the compiler</li>
<li><code>{{foreign}}</code>: The foreign directory</li>
</ul>
<p>The compiler skips running the <code>script</code> if all the files in <code>output</code> are newer than <code>input</code>.</p>
<p>When running the <code>script</code>, the compiler sets the current working directory to the module's root directory.</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p>The field <code>foreign</code> is optional. The default value of <code>foreign</code> is:</p>
<pre><code class="language-ens">{
  input [],
  output [],
  script [],
}
</code></pre>
<p>An example of <code>foreign</code> can be found in the <a href="https://github.com/vekatze/neut-core/blob/0570cd5aa17914bef7021b7e88ca1fa421af721e/module.ens#L10">core library</a>.</p>
<div class="info-block">
<p>The compiler links the resulting foreign object files without any name mangling. You're strongly encouraged to prefix names in your foreign sources with your module name and the major version to avoid name collision. You can find an example of prefixed names <a href="https://github.com/vekatze/neut-core/blob/0570cd5aa17914bef7021b7e88ca1fa421af721e/source/foreign.c">here</a>.</p>
</div>
<h2 id="static"><a class="header" href="#static"><code>static</code></a></h2>
<p>The field <code>static</code> defines the list of static files that can be embedded into source files at compile time. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  static {
    some-file &quot;relative/path/from/the/module/root/to/some-file.txt&quot;,
    other-file &quot;relative/path/from/the/module/root/to/other-file.txt&quot;,
  },
  // ..
}
</code></pre>
<p>You can use the keys defined here in source files using <code>import</code> and <code>include-text</code>:</p>
<pre><code class="language-neut">// foo.nt

import {
  // ..
  static {some-file, other-file}
  // ..
}

define use-some-file(): unit {
  let t1: &amp;text = include-text(some-file) in
  let t2: &amp;text = include-text(other-file) in
  print(t1);
  print(t2)
}
</code></pre>
<p>After specifying a key of a static source file in <code>import</code>, you can use it in <code>include-text</code> to embed the file's content to the source file at compile time. Here, <code>include-text</code> assumes that the encoding of the static file is UTF-8.</p>
<p>The compiler triggers recompilation when necessary by comparing the modification times of static resources and source files. In the code above, for example, the compiler recompiles <code>foo.nt</code> if you modify the content of <code>some-file.txt</code>.</p>
<p>The field <code>static</code> is optional. The default value of <code>static</code> is <code>{}</code>.</p>
<h2 id="preset"><a class="header" href="#preset"><code>preset</code></a></h2>
<p>The field <code>preset</code> defines the list of names that must be imported implicitly when the module is used as a dependency. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  preset {
    foo [&quot;my-func&quot;, &quot;other-func&quot;],
    item.bar [&quot;hoge&quot;, &quot;pohe&quot;],
  },
  // ..
}
</code></pre>
<p>In the example above, the current module is expected to have the following files:</p>
<ul>
<li><code>(source-dir)/foo.nt</code> that contains the definitions of <code>my-func</code> and <code>other-func</code></li>
<li><code>(source-dir)/item/bar.nt</code> that contains the definitions of <code>hoge</code> and <code>pohe</code></li>
</ul>
<p>The field <code>preset</code> is used in combination with <code>enable-preset</code> in <code>dependency</code>.</p>
<p>Suppose we released a module that contains the definition of <code>preset</code> as in the above. Also, suppose someone is developing a module <code>MMM</code> and they added our module to <code>MMM</code>'s dependency:</p>
<pre><code class="language-ens">// module.ens in MMM

{
  // ..
  dependency {
    sample {
      digest &quot;BASE64_URL_ENCODED_SHA256_CHECKSUM&quot;,
      mirror [&quot;SOME_URL&quot;],
      enable-preset true,
    },
    // ..
  },
  // ..
}
</code></pre>
<p>In this case, source files in <code>MMM</code> imports our preset names automatically since <code>enable-preset</code> is <code>true</code>.</p>
<p>As an example, suppose a file in <code>MMM</code> contains an <code>import</code> like the below:</p>
<pre><code class="language-neut">import {
  sample.foo {my-func, other-func},
  sample.item.bar {hoge, pohe},
}

define buz() {
  let i = my-func() in
  print-int(i)
}
</code></pre>
<p>This code is the same as the following since the preset is enabled:</p>
<pre><code class="language-neut">define buz() {
  let i = my-func() in
  print-int(i)
}
</code></pre>
<p>The field <code>preset</code> is expected to be used as a way to realize &quot;preludes&quot; in other languages.</p>
<p>The field <code>preset</code> is optional. The default value of <code>preset</code> is <code>{}</code>.</p>
<h2 id="inline-limit"><a class="header" href="#inline-limit"><code>inline-limit</code></a></h2>
<p>The field <code>inline-limit</code> defines the limit on recursion performed during compilation. It should look like the below:</p>
<pre><code class="language-ens">{
  // ..
  inline-limit 100000,
  // ..
}
</code></pre>
<p>During compilation, the compiler performs possibly recursive computation when:</p>
<ul>
<li>type-checking, and</li>
<li>expanding the definitions of inline functions.</li>
</ul>
<p>The <code>inline-limit</code> specifies a limit here. If the limit is exceeded, the compiler reports an error like the following:</p>
<pre><code class="language-text">/path/to/file.nt:123:45
Error: Exceeded max recursion depth of 1000 during (..)
</code></pre>
<p>The field <code>inline-limit</code> is optional. The default value of <code>inline-limit</code> is <code>1000000</code>.</p>
<h2 id="antecedent"><a class="header" href="#antecedent"><code>antecedent</code></a></h2>
<p>The <em>internal</em> field <code>antecedent</code> defines the list of older compatible versions. This field should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  antecedent [
    &quot;Bp8RulJ-XGTL9Eovre0yQupJpeS3lGNk8Q6QQYua7ag&quot;,
    // ..
    &quot;zptXghmyD5druBl8kx2Qrei6O6fDsKCA7z2KoHp1aqA&quot;,
  ],
  // ..
}
</code></pre>
<p>This information is used to select the newest compatible version of the module. For more information, see the explanation on <code>neut archive</code> in <a href="./commands.html">Commands</a>.</p>
<p>The field <code>antecedent</code> is optional. The default value of <code>antecedent</code> is <code>[]</code>.</p>
<p>This field must be modified <em>only by the compiler</em>. If you modify this field manually, the behavior of the compiler is undefined.</p>
<div class="info-block">
<p>Internally, the compiler treats a module as a library if and only if the module's <code>module.ens</code> contains the key <code>antecedent</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="statements.html#import">import</a></li>
<li><a href="statements.html#define">define</a></li>
<li><a href="statements.html#inline">inline</a></li>
<li><a href="statements.html#data">data</a></li>
<li><a href="statements.html#resource">resource</a></li>
<li><a href="statements.html#nominal">nominal</a></li>
<li><a href="statements.html#foreign">foreign</a></li>
</ul>
<h2 id="import"><a class="header" href="#import"><code>import</code></a></h2>
<p><code>import</code> imports names from other files. It should look like the following:</p>
<pre><code class="language-neut">import {
  Qux,
  ZZ,
  sample.buz,
  this.foo,
  this.item.bar {some-func, other-func},
}
</code></pre>
<p><code>import</code> can only be at the top of a file.</p>
<h3 id="regular-entry"><a class="header" href="#regular-entry">Regular Entry</a></h3>
<p>A regular entry in <code>import</code> is something like the following:</p>
<ul>
<li><code>this.foo</code></li>
<li><code>this.item.bar {some-func, other-func}</code></li>
<li><code>sample.buz</code></li>
</ul>
<p>A regular entry starts from the alias of the module (<code>this</code>, <code>sample</code>). The alias of the module is specified in <code>dependency</code> in <code>module.ens</code>. If the file we want to import is inside the current module, we'll write <code>this</code>.</p>
<p>The remaining part of the regular entry is the relative path from the source directory. For example, if we want to import <code>(source-dir)/item/bar</code>, we'll have to write <code>item.bar</code> after the alias of the module.</p>
<p>A regular entry can be constructed by concatenating the alias and the path with <code>.</code>. In the case of <code>this.item.bar</code>, the alias part is <code>this</code>, and the path part is <code>item.bar</code>.</p>
<p>You can specify names in <code>{}</code>. The names specified here can be used without qualifiers:</p>
<pre><code class="language-neut">import {
  this.item.bar {some-func},
}

define yo(): unit {
  some-func(arg-1, arg-2)
}
</code></pre>
<p>Unlisted names must be qualified:</p>
<pre><code class="language-neut">import {
  this.item.bar,
}

define yo(): unit {
  this.item.bar.some-func(arg-1, arg-2)
}
</code></pre>
<p>You can also list static files in <code>import</code>:</p>
<pre><code class="language-neut">import {
  static {some-file, other-file}
}
</code></pre>
<p>For more on static files, please see <a href="modules.html#static">the section in Modules</a>.</p>
<h3 id="prefix-entry"><a class="header" href="#prefix-entry">Prefix Entry</a></h3>
<p>A prefix entry in <code>import</code> is something like <code>Qux</code> or <code>ZZ</code>. That is, a capitalized name that doesn't contain any <code>.</code>.</p>
<p>A prefix entry in <code>import</code> must be defined in the <code>prefix</code> of the current module's <code>module.ens</code>. Suppose that <code>module.ens</code> contains the following:</p>
<pre><code class="language-ens">{
  // ..
  prefix {
    Qux &quot;this.item.bar&quot;,
  },
  // ..
}
</code></pre>
<p>Then, the code</p>
<pre><code class="language-neut">import {
  this.item.bar,
}

define use-some-func(): unit {
  this.item.bar.some-func()
}
</code></pre>
<p>can be rewritten into:</p>
<pre><code class="language-neut">import {
  Qux,
}

define use-some-func(): unit {
  Qux.some-func()
}
</code></pre>
<p>You may also want to see the explanation of <code>prefix</code> in <a href="./modules.html">Modules</a>.</p>
<h2 id="define"><a class="header" href="#define"><code>define</code></a></h2>
<p><code>define</code> defines a function. It should look like the following:</p>
<pre><code class="language-neut">define foo(x: int, y: int): int {
  add-int(x, y)
}

define identity-1(a: type, x: a): a {
  x
}

// a function with an implicit argument
define identity-2&lt;a&gt;(x: a): a {
  x
}
</code></pre>
<p>Defined functions can then be used:</p>
<pre><code class="language-neut">define use-foo(): int {
  foo(1, 2)
}
</code></pre>
<p><code>define</code> can optionally have implicit arguments, as in <code>identity-2</code> in the above example. The compiler inserts these implicit arguments at compile time, so you don't have to write them explicitly:</p>
<pre><code class="language-neut">define use-func-with-implicit-arg(): int {
  let x = 10 in
  let y = identity-1(int, x) in // ← explicit version
  let z = identity-2(x) in      // ← implicit version
  z
}
</code></pre>
<p>You can also use <code>define</code> without any explicit arguments:</p>
<pre><code class="language-neut">define foo: int {
  10
}

define empty-list&lt;a&gt;: list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo in
  empty-list
}
</code></pre>
<p>The above code is translated into the following during compile time:</p>
<pre><code class="language-neut">define foo(): int {
  10
}

define empty-list&lt;a&gt;(): list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo() in
  empty-list()
}
</code></pre>
<p>The compiler tries to reduce the body of a <code>define</code> into a value at compile time if the <code>define</code> doesn't have any explicit arguments. The compiler reports an error if it can't get a value. For example, the following should result in an error:</p>
<pre><code class="language-neut">define bar: int {
  print(&quot;hello&quot;);
  123
}
</code></pre>
<p>A function with the same name can't be defined in the same file.</p>
<p>All the tail-recursions in Neut are optimized into loops (thanks to geniuses in the LLVM team).</p>
<p>Note that statements are order-sensitive as in F#. Thus, the following code results in an error:</p>
<pre><code class="language-neut">define bar(): int {
  foo() // `foo` is undefined here
}

define foo(): int {
  10
}
</code></pre>
<p>You have to use the statement <code>nominal</code> explicitly for forward references.</p>
<h2 id="inline"><a class="header" href="#inline"><code>inline</code></a></h2>
<p><code>inline</code> defines an inline function. It should look like the following:</p>
<pre><code class="language-neut">inline foo(x: int, y: int): int {
  print(&quot;foo&quot;);
  add-int(x, y)
}
</code></pre>
<p><code>inline</code> is the same as <code>define</code> except that the definition is always expanded at compile-time. For example, if you write</p>
<pre><code class="language-neut">define use-inline-foo(): int {
  let val =
    foo(10, 20)
  in
  val
}
</code></pre>
<p>The compiler will translate the above code into the following:</p>
<pre><code class="language-neut">define use-inline-foo(): int {
  let val =
    let tmp1 = 10 in
    let tmp2 = 20 in
    print(&quot;foo&quot;);
    add-int(tmp1, tmp2)
  in
  val
}
</code></pre>
<p>You can also use <code>inline</code> without any explicit arguments:</p>
<pre><code class="language-neut">inline foo: int {
  10
}

inline empty-list&lt;a&gt;: list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo in
  empty-list
}
</code></pre>
<p>The above code is translated into the following during compile time:</p>
<pre><code class="language-neut">inline foo(): int {
  10
}

inline empty-list&lt;a&gt;(): list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo() in
  empty-list()
}
</code></pre>
<p>The compiler tries to reduce the body of an <code>inline</code> into a value at compile time if the <code>inline</code> doesn't have any explicit arguments. The compiler reports an error if it can't get a value. For example, the following should result in an error:</p>
<pre><code class="language-neut">inline bar: int {
  print(&quot;hello&quot;);
  123
}
</code></pre>
<h2 id="data"><a class="header" href="#data"><code>data</code></a></h2>
<p><code>data</code> defines an algebraic data type (ADT). It should look like the following:</p>
<pre><code class="language-neut">data nat {
| Zero
| Succ(nat)
}

data list(a) {
| Nil
| Cons(a, list(a))
}

data config {
| Config(
    count: int,
    foo-path: &amp;text,
    colorize: bool,
  )
}
</code></pre>
<p>You can use the content of an ADT value by using <code>match</code> or <code>case</code>:</p>
<pre><code class="language-neut">define length&lt;a&gt;(xs: list(a)): int {
  // destruct ADT values using `match`
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}

define length-noetic&lt;a&gt;(xs: &amp;list(a)): int {
  // read noetic ADT values using `case`
  case xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length-noetic(ys))
  }
}

define use-config(c: config) {
  // pattern-matching in `let` is also possible
  let Config of {count, some-path} = c in
  print(count)
}
</code></pre>
<h2 id="resource"><a class="header" href="#resource"><code>resource</code></a></h2>
<p><code>resource</code> defines a new type by specifying how to discard/copy the values of the type. It should look like the following:</p>
<pre><code class="language-neut">resource my-new-type {
  function (value: pointer) {
    // .. discard the value ..
  },
  function (value: pointer) {
    // .. create a new clone of the value and return it as int ..
  },
}
</code></pre>
<p><code>resource</code> takes two terms. The first term (&quot;discarder&quot;) receives a value of the type and discards the value. The second term (&quot;copier&quot;) receives a value of the type and returns the clone of the value (keeping the original value intact).</p>
<p>The type of a discarder is <code>(a) -&gt; unit</code> for some <code>a</code>. You might want to call functions like <code>free</code> in this term.</p>
<p>The type of a copier is <code>(int) -&gt; int</code> for some <code>a</code>. This <code>a</code> must be the same as the <code>a</code> used in the discarder. You might want to call functions like <code>malloc</code> in this term.</p>
<p>For example, the following is a definition of a &quot;boxed&quot; integer type with some noisy messages:</p>
<pre><code class="language-neut">resource boxed-int {
  // discarder: (pointer) -&gt; unit
  function (v: pointer) {
    print(&quot;discarded!\n&quot;);
    free(v)
  },
  // copier: (pointer) -&gt; pointer
  function (v: pointer) {
    let orig-value = load-int(v) in
    let new-ptr = malloc(1) in
    magic store(int, orig-value, new-ptr);
    new-ptr
  },
}

// provide a way to introduce new boxed integer
define create-new-boxed-int(x: int): boxed-int {
  let new-ptr = malloc(8) in
  store-int(x, new-ptr);
  magic cast(int, boxed-int, new-ptr)
}
</code></pre>
<p>A value of type <code>boxed-int</code> prints <code>&quot;discarded!\n&quot;</code> when the value is discarded.</p>
<p><code>resource</code> can be used to define low-level types like arrays.</p>
<p>You can find an example usage of <code>resource</code> in the <code>binary.nt</code> in the <a href="https://github.com/vekatze/neut-core/blob/main/source/binary.nt">core library</a>.</p>
<h2 id="nominal"><a class="header" href="#nominal"><code>nominal</code></a></h2>
<p><code>nominal</code> declares functions for forward references. It should look like the following:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int,
}
</code></pre>
<p>An entry of <code>nominal</code> is the same form as found in <code>define</code>. Nominal definitions can be used to achieve mutual recursions:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int, // nominal definition of `is-odd`
}

// given a non-negative integer `x`, returns true if `x` is even.
define is-even(x: int): bool {
  if eq-int(x, 0) {
    True
  } else {
    is-odd(sub-int(x, 1)) // ← using nominal definition
  }
}

// given a non-negative integer `x`, returns true if `x` is odd.
// (&quot;real&quot; definition of `is-odd`)
define is-odd(x: int): bool {
  if eq-int(x, 0) {
    False
  } else {
    is-even(sub-int(x, 1))
  }
}
</code></pre>
<p>If a nominal definition isn't followed by a real definition, the compiler reports an error.</p>
<h2 id="foreign-1"><a class="header" href="#foreign-1"><code>foreign</code></a></h2>
<p><code>foreign</code> declares functions that are defined in linked objects. It should look like the following:</p>
<pre><code class="language-neut">foreign {
  neut_myapp_v1_add_const(int): int,
}
</code></pre>
<p>Foreign functions declared here can be called by using <code>magic external(..)</code>.</p>
<p>Suppose that you have a C source file with the following definition:</p>
<pre><code class="language-c">// add_const.c

int neut_myapp_v1_add_const(int value) {
  return value + 100;
}
</code></pre>
<p>You can add the field <code>foreign</code> to your <code>module.ens</code> to compile and link this C source file, as written <a href="modules.html#foreign">here</a>. Under this setting, the following code can utilize <code>neut_myapp_v1_add_const</code>:</p>
<pre><code class="language-neut">foreign {
  neut_myapp_v1_add_const(int): int,
}

define main(): unit {
  let x: int = 10 in
  print-int(magic external neut_myapp_v1_add_const(x)); // ← `magic external` is used here
  print(&quot;\n&quot;)
}
</code></pre>
<p>An example project that uses <code>foreign</code> can be found <a href="https://github.com/vekatze/neut/tree/main/test/misc/foreign">here</a>.</p>
<p>You can also use LLVM intrinsics. For example, the LLVM langref states that <code>llvm.sin.*</code> intrinsic is <a href="https://llvm.org/docs/LangRef.html#llvm-sin-intrinsic">available</a>:</p>
<pre><code class="language-llvm">declare float     @llvm.sin.f32(float  %Val)
declare double    @llvm.sin.f64(double %Val)
declare x86_fp80  @llvm.sin.f80(x86_fp80  %Val)
declare fp128     @llvm.sin.f128(fp128 %Val)
declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128  %Val)
</code></pre>
<p>Thus, the next is a valid use of <code>foreign</code>:</p>
<pre><code class="language-neut">foreign {
  llvm.sin.f64(float): float,
}

define sin(x: float): float {
  magic external llvm.sin.f64(x)
}
</code></pre>
<p>Syscall wrapper functions and library functions are also available:</p>
<pre><code class="language-neut">foreign {
  exit(c-int): void,
  sleep(c-int): c-int,
}
</code></pre>
<p>Here, the definition of <code>c-int</code> is as follows:</p>
<pre><code class="language-neut">inline _c-int: type {
  introspect architecture {
  | amd64 =&gt;
    int32
  | arm64 =&gt;
    int32
  }
}

data c-int {
| C-Int(_c-int)
}
</code></pre>
<p>The type of each argument in every foreign entry must be a term that compiles to one of <code>int{N}</code>, <code>float{N}</code>, or <code>pointer</code> during compilation. For example, the <code>c-int</code> in <code>exit(c-int): void</code> is valid because it compiles to <code>int32</code> (thanks to an optimization like Haskell's <code>newtype</code>).</p>
<p>The resulting type of every foreign entry must be <code>void</code> or a term that compiles to one of <code>int{N}</code>, <code>float{N}</code>, or <code>pointer</code> during compilation.</p>
<p>When declaring a variadic function, declare only the non-variadic part:</p>
<pre><code class="language-neut">foreign {
  printf(pointer): void,
}
</code></pre>
<p>Then, specify the types of variadic arguments when using <code>magic external</code>:</p>
<pre><code class="language-neut">define print(t: &amp;text): unit {
  // ..
  magic external printf(fmt)(len: int, val: pointer)
  //                         ^^^^^^^^^^^^^^^^^^^^^^
  //                         passing variadic arguments with types
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terms"><a class="header" href="#terms">Terms</a></h1>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<h3 id="basics"><a class="header" href="#basics">Basics</a></h3>
<ul>
<li><a href="terms.html#type">type</a></li>
<li><a href="terms.html#local-variables">Local Variables</a></li>
<li><a href="terms.html#top-level-variables">Top-Level Variables</a></li>
<li><a href="terms.html#let">let</a></li>
</ul>
<h3 id="primitive-value"><a class="header" href="#primitive-value">Primitive Value</a></h3>
<ul>
<li><a href="terms.html#integers">Integers</a></li>
<li><a href="terms.html#floats">Floats</a></li>
<li><a href="terms.html#texts">Texts</a></li>
<li><a href="terms.html#runes">Runes</a></li>
</ul>
<h3 id="function"><a class="header" href="#function">Function</a></h3>
<ul>
<li><a href="terms.html#x1-a1--xn-an---b">(x1: a1, ..., xn: an) -&gt; b</a></li>
<li><a href="terms.html#function-x1-a1--xn-an--e-">function (x1: a1, ..., xn: an) { e }</a></li>
<li><a href="terms.html#define-fx1-a1--xn-an-c--e-">define f(x1: a1, ..., xn: an): c { e }</a></li>
<li><a href="terms.html#ee1--en">e(e1, ..., en)</a></li>
<li><a href="terms.html#e-of-x1--e1--xn--en">e of {x1 = e1, ..., xn = en}</a></li>
<li><a href="terms.html#exact-e">exact e</a></li>
</ul>
<h3 id="adt"><a class="header" href="#adt">ADT</a></h3>
<ul>
<li><a href="terms.html#adt-formation">ADT Formation</a></li>
<li><a href="terms.html#constructors-adt-introduction">Constructors</a></li>
<li><a href="terms.html#match">match</a></li>
</ul>
<h3 id="necessity-and-noema"><a class="header" href="#necessity-and-noema">Necessity and Noema</a></h3>
<ul>
<li><a href="terms.html#meta">meta</a></li>
<li><a href="terms.html#a">&amp;a</a></li>
<li><a href="terms.html#box">box</a></li>
<li><a href="terms.html#letbox">letbox</a></li>
<li><a href="terms.html#letbox-t">letbox-T</a></li>
<li><a href="terms.html#case">case</a></li>
</ul>
<h3 id="thread"><a class="header" href="#thread">Thread</a></h3>
<ul>
<li><a href="terms.html#thread">thread</a></li>
<li><a href="terms.html#detach">detach</a></li>
<li><a href="terms.html#attach">attach</a></li>
</ul>
<h3 id="miscs"><a class="header" href="#miscs">Miscs</a></h3>
<ul>
<li><a href="terms.html#quote">quote</a></li>
<li><a href="terms.html#magic">magic</a></li>
<li><a href="terms.html#introspect">introspect</a></li>
<li><a href="terms.html#include-text">include-text</a></li>
<li><a href="terms.html#admit">admit</a></li>
<li><a href="terms.html#assert">assert</a></li>
<li><a href="terms.html#_">_</a></li>
</ul>
<h3 id="syntax-sugar"><a class="header" href="#syntax-sugar">Syntax Sugar</a></h3>
<ul>
<li><a href="terms.html#on">let x on y1, ..., yn = e1 in e2</a></li>
<li><a href="terms.html#e">*e</a></li>
<li><a href="terms.html#use-e-x1--xn-in-cont">use e {x1, ..., xn} in cont</a></li>
<li><a href="terms.html#ex">e::x</a></li>
<li><a href="terms.html#if">if</a></li>
<li><a href="terms.html#when-cond--e-">when cond { e }</a></li>
<li><a href="terms.html#e1-e2">e1; e2</a></li>
<li><a href="terms.html#try-x--e1-in-e2">try x = e1 in e2</a></li>
<li><a href="terms.html#tie-x--e1-in-e2">tie x = e1 in e2</a></li>
<li><a href="terms.html#pin-x--e1-in-e2">pin x = e1 in e2</a></li>
<li><a href="terms.html#t">?t</a></li>
<li><a href="terms.html#e1--en">[e1, ..., en]</a></li>
<li><a href="terms.html#with--bind">with / bind</a></li>
<li><a href="terms.html#e">{e}</a></li>
</ul>
<h2 id="type"><a class="header" href="#type"><code>type</code></a></h2>
<p><code>type</code> is the type of types.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-neut">define sample(): unit {
  // `type` used as a term
  let foo = type in
  Unit
}

// `type` used as a type
define identity(a: type, x: a): a {
  x
}
</code></pre>
<h3 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h3>
<pre><code class="language-neut">type
</code></pre>
<h3 id="semantics-3"><a class="header" href="#semantics-3">Semantics</a></h3>
<p><code>type</code> is compiled into a pointer to <code>base.#.imm</code>.</p>
<h3 id="type-1"><a class="header" href="#type-1">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)
----------------
  Γ ⊢ type: type
</code></pre>
<h2 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h2>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-neut">define sample(): unit {
  // defining/using various local variables
  let x = Unit in
  let foo = x in
  let 'bar = foo in
  let buz' = 'bar in
  let _h-e-l-l-o = buz' in
  let αβγ = _h-e-l-l-o in
  let theSpreadingWideMyNarrowHandsToGatherParadise = αβγ in
  let 冥きより冥き道にぞ入りぬべきはるかに照らせ山の端の月 = Unit in
  let _ = Unit in

  // shadowing (not reassignment)
  let x = Unit in
  let x = type in
  let x =
    function (x: bool) {
      x // x: bool
    }
  in
  Unit
}
</code></pre>
<h3 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h3>
<p>The name of a local variable must satisfy the following conditions:</p>
<ul>
<li>It doesn't contain any of <code>=() &quot;\n\t:;,&lt;&gt;[]{}/*|</code></li>
<li>It doesn't start with <code>A, B, .., Z</code> (the upper case alphabets)</li>
</ul>
<h3 id="semantics-4"><a class="header" href="#semantics-4">Semantics</a></h3>
<p>If the content of a variable <code>x</code> is an immediate value, <code>x</code> is compiled into the name of a register that stores the immediate. Otherwise, <code>x</code> is compiled into the name of a register that stores a pointer to the content.</p>
<h3 id="type-2"><a class="header" href="#type-2">Type</a></h3>
<pre><code class="language-neut">  Γ ⊢ a: type
----------------
Γ, x: a ⊢ x: a
</code></pre>
<h3 id="notes-1"><a class="header" href="#notes-1">Notes</a></h3>
<ul>
<li>The compiler reports unused variables. You can use the name <code>_</code> to suppress those.</li>
<li>Variables in Neut are immutable. You'll need <code>core.cell</code> to achieve mutability.</li>
</ul>
<h2 id="top-level-variables"><a class="header" href="#top-level-variables">Top-Level Variables</a></h2>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-neut">import {
  core.bool {bool},
  B,
}

define sample(): unit {
  // using top-level variables
  let _ = bool // using an imported top-level name
  let _ = core.bool.bool // using the definite description of `core.bool.bool`
  let _ = B.bool // using a prefixed top-level name
  Unit
}
</code></pre>
<h3 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h3>
<p>The name of a top-level variable is a (possibly) dot-separated symbols, where each symbol must satisfy the following conditions:</p>
<ul>
<li>It doesn't contain any of <code>=() &quot;\n\t:;,&lt;&gt;[]{}/*|</code></li>
</ul>
<h3 id="semantics-5"><a class="header" href="#semantics-5">Semantics</a></h3>
<p>A top-level variable <code>f</code> is compiled into the following 3-word tuple:</p>
<pre><code>(base.#.imm, 0, POINTER_TO_FUNCTION(f))
</code></pre>
<p>See the Note below for a more detailed explanation.</p>
<h3 id="type-3"><a class="header" href="#type-3">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)     (c: a is defined at the top-level)
-------------------------------------------------------
                  Γ ⊢ c: a
</code></pre>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>Let's see how top-level variables are compiled. Consider the following top-level functions:</p>
<pre><code class="language-neut">// (source-dir)/sample.nt

// defining a top-level variable `increment`
define increment(x: int): int {
  add-int(x, 1)
}

define get-increment(): (int) -&gt; int {
  increment // using a top-level variable `increment`
}
</code></pre>
<p>This <code>increment</code> and <code>get-increment</code> are compiled into LLVM functions like the below:</p>
<pre><code class="language-llvm">; (build-dir)/path/to/sample.ll

define fastcc ptr @&quot;this.sample.increment&quot;(ptr %_1) {
  %_2 = ptrtoint ptr %_1 to i64
  %_3 = add i64 %_2, 1
  %_4 = inttoptr i64 %_3 to ptr
  ret ptr %_4
}

define fastcc ptr @&quot;this.sample.get-increment&quot;() {
  ; `increment` in `get-increment` is lowered to the following code:

  ; calculate the size of 3-word tuples
  %_1 = getelementptr ptr, ptr null, i32 3
  %_2 = ptrtoint ptr %_1 to i64
  ; allocate memory
  %_3 = call fastcc ptr @malloc(i64 %_2)
  ; store contents
  %_4 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 0
  %_5 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 1
  %_6 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 2
  store ptr @&quot;base.#.imm&quot;, ptr %_4            ; tuple[0] = `base.#.imm`
  store ptr null, ptr %_5                     ; tuple[1] = null
  store ptr @&quot;this.sample.increment&quot;, ptr %_6 ; tuple[2] = (function pointer)
  ; return the pointer to the tuple
  ret ptr %_3
}
</code></pre>
<p>Incidentally, these 3-word tuples are optimized away as long as top-level variables (functions) are called directly with arguments.</p>
<h2 id="let"><a class="header" href="#let"><code>let</code></a></h2>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-neut">define use-let(): unit {
  // 🌟 `let`
  let t = &quot;test&quot; in
  print(t)
}

define use-let(): unit {
  let bar =
    // 🌟 nested `let`
    let foo = some-func() in
    other-func(foo)
  in
  do-something(bar)
}

define use-let(): unit {
  // 🌟 `let` with a type annotation
  let t: &amp;text = &quot;test&quot; in
  print(t)
}

</code></pre>
<p><code>let</code> can be used to destructure an ADT value:</p>
<pre><code class="language-neut">data item {
| Item(int, bool)
}

define use-item(x: item): unit {
  // 🌟 use `let` with a pattern
  let Item(i, b) = x in // ← here
  print-int(i)
}

define use-item-2(x: item): unit {
  // 🌟 use `let` with an of-pattern
  let Item of {i} = x in
  print-int(i)
}
</code></pre>
<h3 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h3>
<pre><code class="language-neut">let x = e1 in e2

let x: t = e1 in e2
</code></pre>
<h3 id="semantics-6"><a class="header" href="#semantics-6">Semantics</a></h3>
<p><code>let x = e1 in e2</code> binds the result of <code>e1</code> to the variable <code>x</code>. This <code>x</code> can then be used in <code>e2</code>.</p>
<h3 id="type-4"><a class="header" href="#type-4">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a     Γ, x: a ⊢ e2: b
-----------------------------
   Γ ⊢ let x = e1 in e2: b
</code></pre>
<h3 id="note-1"><a class="header" href="#note-1">Note</a></h3>
<p>(1) <code>let x = e1 in e2</code> isn't exactly the same as <code>{function (x) {e2}}(e1)</code>. The difference lies in the fact that the type of <code>e2</code> can't depend on <code>x</code> in <code>let x = e1 in e2</code>.</p>
<p>(2) When a pattern is passed, <code>let</code> is the following syntax sugar:</p>
<pre><code class="language-neut">let pat = x in
cont

↓

match x {
| pat =&gt;
  cont
}
</code></pre>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: int = 100 in
  //           ^^^
  let _: int16 = 100 in
  //             ^^^
  Unit
}

</code></pre>
<h3 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h3>
<p><code>3</code>, <code>-16</code>, <code>424242</code>, etc.</p>
<h3 id="semantics-7"><a class="header" href="#semantics-7">Semantics</a></h3>
<p>The same as LLVM integers.</p>
<h3 id="type-5"><a class="header" href="#type-5">Type</a></h3>
<p>The type of an integer is unknown in itself. It must be inferred to be one of the following types:</p>
<ul>
<li><code>int1</code></li>
<li><code>int2</code></li>
<li>...</li>
<li><code>int64</code></li>
</ul>
<h3 id="note-2"><a class="header" href="#note-2">Note</a></h3>
<ul>
<li>The type <code>int</code> is also available. For more, see <a href="./primitives.html#primitive-types">Primitives</a>.</li>
</ul>
<h2 id="floats"><a class="header" href="#floats">Floats</a></h2>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: float = 3.8 in
  //             ^^^
  let _: float32 = 3.8 in
  //             ^^^^^^
  Unit
}

</code></pre>
<h3 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h3>
<p><code>3.8</code>, <code>-0.2329</code>, etc.</p>
<h3 id="semantics-8"><a class="header" href="#semantics-8">Semantics</a></h3>
<p>The same as LLVM floats.</p>
<h3 id="type-6"><a class="header" href="#type-6">Type</a></h3>
<p>The type of an integer is unknown in itself. It must be inferred to be one of the following types:</p>
<ul>
<li><code>float16</code></li>
<li><code>float32</code></li>
<li><code>float64</code></li>
</ul>
<h3 id="note-3"><a class="header" href="#note-3">Note</a></h3>
<ul>
<li>The type <code>float</code> is also available. For more, see <a href="./primitives.html#primitive-types">Primitives</a>.</li>
</ul>
<h2 id="runes"><a class="header" href="#runes">Runes</a></h2>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: rune = `A` in
  //            ^^^
  let _: rune = `\n` in
  //            ^^^
  let _: rune = `\n` in
  //            ^^^
  Unit
}

</code></pre>
<h3 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h3>
<p><code>`A`</code>, <code>`\n`</code>, <code>`\u{123}`</code>, etc.</p>
<p>The available escape sequences in rune literals are the same as those of <a href="./terms.html#texts">text literals</a>.</p>
<h3 id="semantics-9"><a class="header" href="#semantics-9">Semantics</a></h3>
<p>The value of a rune literal is a Unicode codepoint encoded in UTF-8.</p>
<p>The underlying representation of a rune is an int32.</p>
<h3 id="type-7"><a class="header" href="#type-7">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)  (c is a rune literal)
---------------------------------------
         Γ ⊢ c: rune
</code></pre>
<h3 id="note-4"><a class="header" href="#note-4">Note</a></h3>
<p>(1) You can write <code>`\1234`</code>, for example, to represent U+1234 (<code>`ሴ`</code>).</p>
<p>(2) We have the following equalities, for example:</p>
<pre><code class="language-neut">`A` == magic cast(int32, rune, 0x41)
`Γ` == magic cast(int32, rune, 0xCE93)
`あ` == magic cast(int32, rune, 0xE38182)
`⭐` == magic cast(int32, rune, 0xE2AD90)
</code></pre>
<p>You can see this by calling the following function:</p>
<pre><code class="language-neut">define print-star(): unit {
  // prints &quot;⭐&quot;
  printf(&quot;{}\n&quot;, [core.text.singleton(magic cast(int32, rune, 0xE2AD90))])
}
</code></pre>
<h2 id="texts"><a class="header" href="#texts">Texts</a></h2>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: &amp;text = &quot;test&quot; in
  //             ^^^^^^
  Unit
}

</code></pre>
<h3 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h3>
<p><code>&quot;hello&quot;</code>, <code>&quot;Hello, world!\n&quot;</code>, <code>&quot;\u{1f338} ← Cherry Blossom&quot;</code>, etc.</p>
<p>Below is the list of all the escape sequences in Neut:</p>
<div class="table-wrapper"><table><thead><tr><th>Escape Sequence</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>\0</code></td><td>U+0000 (null character)</td></tr>
<tr><td><code>\t</code></td><td>U+0009 (horizontal tab)</td></tr>
<tr><td><code>\n</code></td><td>U+000A (line feed)</td></tr>
<tr><td><code>\r</code></td><td>U+000D (carriage return)</td></tr>
<tr><td><code>\&quot;</code></td><td>U+0022 (double quotation mark)</td></tr>
<tr><td><code>\\</code></td><td>U+005C (backslash)</td></tr>
<tr><td><code>\`</code></td><td>U+0060 (backtick)</td></tr>
<tr><td><code>\u{n}</code></td><td>U+n</td></tr>
</tbody></table>
</div>
<p>The <code>n</code> in <code>\u{n}</code> must be a lowercase hexadecimal number.</p>
<h3 id="semantics-10"><a class="header" href="#semantics-10">Semantics</a></h3>
<p>A text literal is compiled into a pointer to a tuple like the following:</p>
<pre><code class="language-text">(0, length-of-string, array-of-characters)
</code></pre>
<p>This tuple is static. More specifically, a global constant like the following is inserted into the resulting IR.</p>
<pre><code class="language-llvm">@&quot;text-hello&quot; = private unnamed_addr constant {i64, i64, [5 x i8]} {i64 0, i64 5, [5 x i8] c&quot;hello&quot;}
</code></pre>
<p>And a text like <code>&quot;hello&quot;: &amp;text</code> is compiled into <code>ptr @&quot;text-hello&quot;</code>.</p>
<h3 id="type-8"><a class="header" href="#type-8">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)  (t is a text literal)
---------------------------------------
         Γ ⊢ t: &amp;text
</code></pre>
<h3 id="note-5"><a class="header" href="#note-5">Note</a></h3>
<ul>
<li>In the current implementation, the set of recognized escape sequences like <code>\n</code> or <code>\t</code> are the same as that of Haskell.</li>
</ul>
<h2 id="x1-a1--xn-an---b"><a class="header" href="#x1-a1--xn-an---b"><code>(x1: a1, ..., xn: an) -&gt; b</code></a></h2>
<p><code>(x1: a1, ..., xn: an) -&gt; b</code> is the type of functions.</p>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<pre><code class="language-neut">// a function that accepts ints and returns bools
(value: int) -&gt; bool

// this is equivalent to `(_: int) -&gt; bool`:
(int) -&gt; bool

// use a type variable
(a: type, x: a) -&gt; a

// make the first argument implicit
&lt;a: type&gt;(x: a) -&gt; a

// this is equivalent to `&lt;a: _&gt;(x: a) -&gt; a`
&lt;a&gt;(x: a) -&gt; a
</code></pre>
<h3 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h3>
<pre><code class="language-neut">&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<p>The following abbreviations are available:</p>
<pre><code class="language-neut">(y1: b1, ..., ym: bm) -&gt; c

// ↓
// &lt;&gt;(y1: b1, ..., ym: bm) -&gt; c


(b1, ..., bm) -&gt; c

// ↓
// (_: b1, ..., _: bm) -&gt; c


&lt;a1, ..., an&gt;(y1: b1, ..., ym: bm) -&gt; c

// ↓
// &lt;a1: _, ..., an: _&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<h3 id="semantics-11"><a class="header" href="#semantics-11">Semantics</a></h3>
<p>A function type is compiled into a pointer to <code>base.#.cls</code>. For more, please see <a href="./how-to-execute-types.html">How to Execute Types</a></p>
<h3 id="type-9"><a class="header" href="#type-9">Type</a></h3>
<pre><code class="language-neut">  Γ, x1: a1, ..., xn: an, y1: b1, ..., ym: bm ⊢ c: type
--------------------------------------------------------
Γ ⊢ &lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c: type
</code></pre>
<h2 id="function-x1-a1--xn-an--e-"><a class="header" href="#function-x1-a1--xn-an--e-"><code>function (x1: a1, ..., xn: an) { e }</code></a></h2>
<p><code>function</code> can be used to create a lambda abstraction (an anonymous function).</p>
<h3 id="example-12"><a class="header" href="#example-12">Example</a></h3>
<pre><code class="language-neut">define use-function(): int {
  let f =
    function (x: int, y: int) {
      let z = add-int(x, y) in
      mul-int(z, z)
    }
  in
  f(10, 20)
}
</code></pre>
<h3 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h3>
<pre><code class="language-neut">function (x1: a1, ..., xn: an) {
  e
}
</code></pre>
<p>All the free variables of a <code>function</code> must be at the same layer of the function. For example, the following is not a valid term in Neut:</p>
<pre><code class="language-neut">define return-int(x: meta int): meta () -&gt; int {
  // here is layer 0
  box {
    // here is layer -1
    function () {
      letbox result =
        // here is layer 0
        x // ← error
      in
      result
    }
  }
}
</code></pre>
<p>because the free variable <code>x</code> in the <code>function</code> is at layer 0, whereas the <code>function</code> is at layer -1.</p>
<p>For more on layers, please see the section on <a href="terms.html#box">box</a>, <a href="terms.html#letbox">letbox</a>, and <a href="terms.html#letbox-t">letbox-T</a>.</p>
<h3 id="semantics-12"><a class="header" href="#semantics-12">Semantics</a></h3>
<p>A <code>function</code> is compiled into a three-word closure. For more, please see <a href="./how-to-execute-types.html#advanced-function-types">How to Execute Types</a>.</p>
<h3 id="type-10"><a class="header" href="#type-10">Type</a></h3>
<pre><code class="language-neut">    Γ, x1: a1, ..., xn: an ⊢ e: t
-----------------------------------------
Γ ⊢ function (x1: a1, ..., xn: an) {e}: t

</code></pre>
<h3 id="note-6"><a class="header" href="#note-6">Note</a></h3>
<ul>
<li>Lambda abstractions defined by <code>function</code> are reduced at compile-time when possible. If you would like to avoid this behavior, consider using <code>define</code>.</li>
</ul>
<h2 id="define-fx1-a1--xn-an-c--e-"><a class="header" href="#define-fx1-a1--xn-an-c--e-"><code>define f(x1: a1, ..., xn: an): c { e }</code></a></h2>
<p><code>define</code> (at the term-level) can be used to create a function with possible recursion.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<pre><code class="language-neut">define use-define(): int {
  let c = 10 in
  let f =
    // 🌟 term-level `define` with a free variable `c`
    define some-recursive-func(x: int): int {
      if eq-int(x, 0) {
        0
      } else {
        add-int(c, some-recursive-func(sub-int(x, 1)))
      }
    }
  in
  f(100)
}
</code></pre>
<h3 id="syntax-13"><a class="header" href="#syntax-13">Syntax</a></h3>
<pre><code class="language-neut">define name&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm): c {
  e
}
</code></pre>
<p>The following abbreviations are available:</p>
<pre><code class="language-neut">define name(y1: b1, ..., ym: bm): c {e}

// ↓
// define name&lt;&gt;(y1: b1, ..., ym: bm): c {e}


define name&lt;a1, ..., an&gt;(y1: b1, ..., ym: bm): c {e}

// ↓
// define name&lt;a1: _, ..., an: _&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<p>As in <code>function</code>, all the free variables of a <code>define</code> must be at the same layer of the <code>define</code>.</p>
<h3 id="semantics-13"><a class="header" href="#semantics-13">Semantics</a></h3>
<p>A term-level <code>define</code> is lifted to a top-level definition using lambda lifting. For example, consider the following example:</p>
<pre><code class="language-neut">define use-define(): int {
  let c = 10 in
  let f =
    // 🌟 term-level `define` with a free variable `c`
    define some-recursive-func(x: int): int {
      if eq-int(x, 0) {
        0
      } else {
        add-int(c, some-recursive-func(sub-int(x, 1)))
      }
    }
  in
  f(100)
}
</code></pre>
<p>The code above is compiled into something like the below:</p>
<pre><code class="language-neut">// the free variable `c` is now a parameter
define some-recursive-func(c: int, x: int): int {
  if eq-int(x, 0) {
    0
  } else {
    let f =
      function (x: int) {
        some-recursive-func(c, x)
      }
    in
    add-int(c, f(sub-int(x, 1)))
  }
}

define use-define(): int {
  let c = 10 in
  let f =
    function (x: int) {
      some-recursive-func(c, x)
    }
  in
  f(100)
}
</code></pre>
<h3 id="type-11"><a class="header" href="#type-11">Type</a></h3>
<pre><code class="language-neut">Γ, x1: a1, ..., xn: an, f: (x1: a1, ..., xn: an) -&gt; t ⊢ e: t
------------------------------------------------------------
     Γ ⊢ (define f(x1: a1, ..., xn: an):t {e}): t
</code></pre>
<h3 id="note-7"><a class="header" href="#note-7">Note</a></h3>
<ul>
<li>Functions defined by term-level <code>define</code> aren't inlined at compile-time, even if it doesn't contain any recursions.</li>
</ul>
<h2 id="ee1--en"><a class="header" href="#ee1--en"><code>e(e1, ..., en)</code></a></h2>
<p>Given a function <code>e</code> and arguments <code>e1, ..., en</code>, we can write <code>e(e1, ..., en)</code> to write a function application.</p>
<h3 id="example-14"><a class="header" href="#example-14">Example</a></h3>
<pre><code class="language-neut">define use-function(): unit {
  let _ = foo() in
  //      ^^^^^
  let _ = bar(1) in
  //      ^^^^^^
  let _ = buz(&quot;hello&quot;, True) in
  //      ^^^^^^^^^^^^^^^^^^
  Unit
}
</code></pre>
<h3 id="syntax-14"><a class="header" href="#syntax-14">Syntax</a></h3>
<pre><code class="language-neut">e(e1, ..., en)
</code></pre>
<h3 id="semantics-14"><a class="header" href="#semantics-14">Semantics</a></h3>
<p>Given a funciton application <code>e(e1, ..., en)</code> the system does the following:</p>
<ol>
<li>Computes <code>e</code>, <code>e1</code>, ..., <code>en</code> into values <code>v</code>, <code>v1</code>, ..., <code>vn</code></li>
<li>Extracts the content of the closure <code>v</code>, obtaining the label of the closed function and the tuple of the free variables</li>
<li>Deallocates the tuple of the closure <code>v</code></li>
<li>Calls the function label with the tuple and <code>v1, ..., vn</code> as arguments</li>
</ol>
<h3 id="type-12"><a class="header" href="#type-12">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: &lt;x1: a1, .., xn: an&gt;(y1: b1, .., ym: bm) -&gt; c    Γ ⊢ e1: b1  ..   Γ ⊢ em: bm
---------------------------------------------------------------------------------------
    Γ ⊢ e(e1, .., en): c[x1 := ?M1, .., xn := ?Mn, y1 := e1, .., ym := em]
</code></pre>
<p>The <code>?Mi</code>s in the above rule are metavariables that must be inferred by the compiler.</p>
<h3 id="note-8"><a class="header" href="#note-8">Note</a></h3>
<p>If the function <code>e</code> contains implicit arguments, holes are inserted automatically.</p>
<p>For example, consider the following code:</p>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id(): unit {
  id(Unit)
}
</code></pre>
<p>The <code>id(Unit)</code> in the example above is (conceptually) compiled into the below:</p>
<pre><code class="language-neut">define _id(a: type, x: a): a {
  x
}

define use-id(): unit {
  _id(_, Unit) // ← a hole `_` is inserted here
}
</code></pre>
<h2 id="e-of-x1--e1--xn--en"><a class="header" href="#e-of-x1--e1--xn--en"><code>e of {x1 = e1, ..., xn = en}</code></a></h2>
<p><code>e of {x1 = e1, ..., xn = en}</code> is an alternative notation of function application.</p>
<h3 id="example-15"><a class="header" href="#example-15">Example</a></h3>
<pre><code class="language-neut">define foo(x: int, y: bool, some-path: &amp;text): unit {
  // whatever
}

define use-foo(): unit {
  // 🌟
  foo of {
    x = 10,
    y = True,
    some-path = &quot;/path/to/file&quot;,
  }
}
</code></pre>
<h3 id="syntax-15"><a class="header" href="#syntax-15">Syntax</a></h3>
<pre><code class="language-neut">e of {x1 = e1, ..., xn = en}
</code></pre>
<h3 id="semantics-15"><a class="header" href="#semantics-15">Semantics</a></h3>
<p>The same as <code>e(e1, ..., en)</code>.</p>
<h3 id="type-13"><a class="header" href="#type-13">Type</a></h3>
<p>The same as <code>e(e1, ..., en)</code>.</p>
<h3 id="note-9"><a class="header" href="#note-9">Note</a></h3>
<p>This notation might be useful when used in combination with ADTs:</p>
<pre><code class="language-neut">data config {
| Config(
    count: int,
    path: &amp;text,
    colorize: bool,
  )
}

inline some-config {
  Config of {
    count = 10,
    colorize = True,
    path = &quot;/path/to/file&quot;, // you can reorder arguments
  }
}
</code></pre>
<p>If the argument is a variable that has the same name as the parameter, you can use a shorthand notation:</p>
<pre><code class="language-neut">define use-foo(): unit {
  let x = 10 in
  let y = True in
  let some-path = &quot;/path/to/file&quot;
  // 🌟
  foo of {x, y, some-path}
}
</code></pre>
<h2 id="exact-e"><a class="header" href="#exact-e"><code>exact e</code></a></h2>
<p>Given a function <code>e</code>, <code>exact e</code> supplies all the implicit variables of <code>e</code> by inserting holes.</p>
<h3 id="example-16"><a class="header" href="#example-16">Example</a></h3>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id() {
                           // 🌟
  let g: (x: int) -&gt; int = exact id in
  Unit
}
</code></pre>
<p>Note that the following won't type-check:</p>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id() {
  let g: (x: int) -&gt; int = id in
  Unit
}
</code></pre>
<p>This is because the type of <code>id</code> is <code>&lt;a&gt;(x: a) -&gt; a</code>, not <code>(x: ?M) -&gt; ?M</code>.</p>
<h3 id="syntax-16"><a class="header" href="#syntax-16">Syntax</a></h3>
<pre><code class="language-neut">exact e
</code></pre>
<h3 id="semantics-16"><a class="header" href="#semantics-16">Semantics</a></h3>
<p>Given a term <code>e</code> of type <code>&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c</code>,</p>
<pre><code class="language-neut">exact e
</code></pre>
<p>is translated into the following:</p>
<pre><code class="language-neut">function (y1: b1, ..., ym: bm) {
  e(_, ..., _, y1, ..., ym)
}
</code></pre>
<h3 id="type-14"><a class="header" href="#type-14">Type</a></h3>
<pre><code class="language-neut">       Γ ⊢ e: &lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c
--------------------------------------------------------------------
Γ ⊢ exact e: ((y1: b1, ..., ym: bm) -&gt; c)[x1 := ?M1, ..., xn := ?Mn]
</code></pre>
<p>Here, <code>?Mi</code>s are metavariables that must be inferred by the type checker.</p>
<h3 id="note-10"><a class="header" href="#note-10">Note</a></h3>
<p>As you can see from its semantics, an <code>exact</code> is just a shorthand of a &quot;hole-application&quot;.</p>
<h2 id="adt-formation"><a class="header" href="#adt-formation">ADT Formation</a></h2>
<p>After defining an ADT using the statement <code>data</code>, you can use the ADT.</p>
<h3 id="example-17"><a class="header" href="#example-17">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define use-nat-type(): type {
  // 🌟
  my-nat
}
</code></pre>
<h3 id="syntax-17"><a class="header" href="#syntax-17">Syntax</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="semantics-17"><a class="header" href="#semantics-17">Semantics</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="type-15"><a class="header" href="#type-15">Type</a></h3>
<p>If an ADT <code>some-adt</code> is nullary, the type of <code>some-adt</code> is <code>type</code>.</p>
<p>Otherwise, suppose that an ADT <code>some-adt</code> is defined as follows:</p>
<pre><code class="language-neut">data some-adt(x1: a1, ..., xn: an) {..}
</code></pre>
<p>In this case, the type of <code>some-adt</code> is <code>(x1: a1, ..., xn: an) -&gt; type</code>.</p>
<h2 id="constructors-adt-introduction"><a class="header" href="#constructors-adt-introduction">Constructors (ADT Introduction)</a></h2>
<p>After defining an ADT using the statement <code>data</code>, you can use the constructors to construct values of the ADT.</p>
<h3 id="example-18"><a class="header" href="#example-18">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define create-nat(): my-nat {
  // 🌟 (`Succ` and `Zero` are constructors)
  Succ(Succ(Zero))
}
</code></pre>
<h3 id="syntax-18"><a class="header" href="#syntax-18">Syntax</a></h3>
<p>The same as that of top-level variables, except that constructors must be capitalized.</p>
<h3 id="semantics-18"><a class="header" href="#semantics-18">Semantics</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="type-16"><a class="header" href="#type-16">Type</a></h3>
<p>If a constructor <code>c</code> is nullary, the type of <code>c</code> is the ADT type. For example, consider the following code:</p>
<pre><code class="language-neut">data some-adt {
| c1
}

data other-adt(a: type) {
| c2
}
</code></pre>
<p>In this case,</p>
<ul>
<li>the type of <code>c1</code> is <code>some-adt</code>, and</li>
<li>the type of <code>c2</code> is <code>other-adt(?M)</code>, where the <code>?M</code> must be inferred by the compiler.</li>
</ul>
<p>If a constructor <code>c</code> isn't nullary, the type of <code>c</code> is the function type that takes specified arguments and turns them into the ADT type. For example, consider the following code:</p>
<pre><code class="language-neut">data some-adt {
| c1(foo: int)
}

data other-adt(a: type) {
| c2(bar: bool, buz: other-adt(a))
}
</code></pre>
<p>In this case,</p>
<ul>
<li>the type of <code>c1</code> is <code>(foo: int) -&gt; some-adt</code>, and</li>
<li>the type of <code>c2</code> is <code>&lt;a: type&gt;(bar: bool, buz: other-adt(a)) -&gt; other-adt(a)</code>.</li>
</ul>
<h2 id="match"><a class="header" href="#match"><code>match</code></a></h2>
<p>You can use <code>match</code> to destructure ADT values or integers.</p>
<h3 id="example-19"><a class="header" href="#example-19">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define foo(n: my-nat): int {
  // 🌟
  match n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo(m)
  }
}

define bar(n: my-nat): int {
  // 🌟 (You can use nested patterns)
  match n {
  | Zero =&gt;
    100
  | Succ(Succ(m)) =&gt; // ← a nested pattern
    200
  | Succ(m) =&gt;
    foo(m)
  }
}

define eq-nat(n1: my-nat, n2: my-nat): bool {
  // 🌟 (`match` can handle multiple values)
  match n1, n2 {
  | Zero, Zero =&gt;
    True
  | Succ(m1), Succ(m2) =&gt;
    eq-nat(m1, m2)
  | _, _ =&gt;
    False
  }
}

define literal-match(x: int): int {
  // 🌟 (You can use `match` against integers)
  match x {
  | 3 =&gt;
    30
  | 5 =&gt;
    50
  | _ =&gt;
    add-int(x, 10)
  }
}
</code></pre>
<h3 id="syntax-19"><a class="header" href="#syntax-19">Syntax</a></h3>
<pre><code class="language-neut">match e1, ..., en {
| pattern-1 =&gt;
  body-1
  ...
| pattern-m =&gt;
  body-m
}
</code></pre>
<h3 id="semantics-19"><a class="header" href="#semantics-19">Semantics</a></h3>
<p>The semantics of <code>match</code> is the same as the semantics of ordinary pattern matching, except that ADT values are <em>consumed</em> after branching.</p>
<p>For example, let's see how <code>my-nat</code> in the following code is used in <code>match</code>:</p>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}
</code></pre>
<p>The internal representation of <code>n: my-nat</code> is something like the below:</p>
<pre><code class="language-neut">Zero:
  (0) // 1-word tuple
Succ:
  (1, pointer-to-m) // 2-word tuple
</code></pre>
<p>When evaluating <code>match</code>, the computer inspects the first element of the &quot;tuple&quot; <code>n</code>.</p>
<pre><code class="language-neut">define foo(n: my-nat): int {
  // 🌟 (inspects the first element of `n` here)
  match n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo(m)
  }
}
</code></pre>
<p>If the first element is <code>0</code>, which means that we found an ADT value of <code>Zero</code>, the computer <em>frees</em> the outer tuple of <code>(0)</code>, and then evaluates <code>100</code>.</p>
<p>If the first element is <code>1</code>, which means that we found an ADT value of <code>Succ</code>, the computer gets the pointer to the second element of <code>n</code>, binds it to <code>m</code>, <em>frees</em> the outer tuple of <code>(1, pointer-to-m)</code>, and then evaluates <code>foo(m)</code>.</p>
<h3 id="type-17"><a class="header" href="#type-17">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a1
...
Γ ⊢ en: an

Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ pat-1: a1
Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ body-1: b

...

Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ pat-m: an
Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ body-m: b

(for all i = 1, ..., m, pat-i is a pattern for e1, ..., en)
(the sequence pat-1, ..., pat-m is a exhaustinve matching against e1, ..., en)
------------------------------------------------------------------------------
Γ ⊢ match e1, ..., en {
    | pat-1 =&gt; body-1
    ...
    | pat-m =&gt; body-m
    }: b
</code></pre>
<p>The above might be a bit overwhelming. Please see the following Note for an example.</p>
<h3 id="note-11"><a class="header" href="#note-11">Note</a></h3>
<p>An example of the application of the typing rule of <code>match</code>:</p>
<pre><code class="language-neut">Γ ⊢ n: my-nat

Γ ⊢ Zero: my-nat // pat-1
Γ ⊢ 100: int // body-1

Γ, m: my-nat ⊢ Succ(m): my-nat // pat-2
Γ, m: my-nat ⊢ foo(m): int // body-2

(Zero and Succ(m) are patterns for n)
(the sequence Zero, Succ(m) is a exhaustinve matching against n)
------------------------------------------------------------------------------
Γ ⊢ match n {
    | Zero =&gt; 100
    | Succ(m) =&gt; foo(m)
    }: int
</code></pre>
<h2 id="meta"><a class="header" href="#meta"><code>meta</code></a></h2>
<p>Given a type <code>a: type</code>, <code>meta a</code> is the type of <code>a</code> in the &quot;outer&quot; layer.</p>
<h3 id="example-20"><a class="header" href="#example-20">Example</a></h3>
<pre><code class="language-neut">                     // 🌟
define axiom-T&lt;a&gt;(x: meta a): a {
  letbox-T result = x in
  result
}
</code></pre>
<h3 id="syntax-20"><a class="header" href="#syntax-20">Syntax</a></h3>
<pre><code class="language-neut">meta a
</code></pre>
<h3 id="semantics-20"><a class="header" href="#semantics-20">Semantics</a></h3>
<p>For every type <code>a</code>, <code>meta a</code> is compiled into the same term as <code>a</code>.</p>
<h3 id="type-18"><a class="header" href="#type-18">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: type
----------------
Γ ⊢ meta t: type
</code></pre>
<h3 id="note-12"><a class="header" href="#note-12">Note</a></h3>
<p><code>meta</code> is the T-necessity operator in that we can construct terms of the following types:</p>
<ul>
<li><code>(meta (a) -&gt; b, meta a) -&gt; meta b</code> (Axiom K)</li>
<li><code>(meta a) -&gt; a</code> (Axiom T)</li>
</ul>
<p>Note that <code>meta (a) -&gt; b</code> means <code>meta {(a) -&gt; b}</code> and not <code>(meta a) -&gt; b</code>.</p>
<h2 id="a"><a class="header" href="#a"><code>&amp;a</code></a></h2>
<p>Given a type <code>a: type</code>, the <code>&amp;a</code> is the type of noemata over <code>a</code>.</p>
<h3 id="example-21"><a class="header" href="#example-21">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

                     // 🌟
define foo-noetic(n: &amp;my-nat): int {
  case n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo-noetic(m)
  }
}
</code></pre>
<h3 id="syntax-21"><a class="header" href="#syntax-21">Syntax</a></h3>
<pre><code class="language-neut">&amp;t
</code></pre>
<h3 id="semantics-21"><a class="header" href="#semantics-21">Semantics</a></h3>
<p>For every type <code>a</code>, <code>&amp;a</code> is compiled into <code>base.#.imm</code>.</p>
<h3 id="type-19"><a class="header" href="#type-19">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: type
-----------
Γ ⊢ &amp;t: type
</code></pre>
<h3 id="note-13"><a class="header" href="#note-13">Note</a></h3>
<ul>
<li>Values of type <code>&amp;a</code> can be created using <code>on</code>.</li>
<li>Values of type <code>&amp;a</code> are expected to be used in combination with <code>case</code> or <code>*e</code>.</li>
<li>Since <code>&amp;a</code> is compiled into <code>base.#.imm</code>, values of type <code>&amp;a</code> aren't discarded or copied even when used non-linearly.</li>
<li>See the Note of <a href="terms.html#box">box</a> to see the relation between <code>&amp;a</code> and <code>meta a</code></li>
</ul>
<h2 id="box"><a class="header" href="#box"><code>box</code></a></h2>
<p><code>box e</code> can be used to &quot;lift&quot; the layer of <code>e</code>.</p>
<h3 id="example-22"><a class="header" href="#example-22">Example</a></h3>
<pre><code class="language-neut">define use-noema&lt;a&gt;(x: &amp;a, y: &amp;a): meta b {
  // layer 0
  // - x: &amp;a at layer 0
  // - y: a  at layer 0
  box x {
    // layer -1
    // x:  a at layer -1
    // y: &amp;a at layer 0 (cannot be used here; causes a layer error)
    x
  }
}
</code></pre>
<h3 id="syntax-22"><a class="header" href="#syntax-22">Syntax</a></h3>
<pre><code class="language-neut">box x1, ..., xn { e } // n &gt;= 0
</code></pre>
<p>We say that this <code>box</code> captures the variables <code>x1, ..., xn</code>.</p>
<h3 id="semantics-22"><a class="header" href="#semantics-22">Semantics</a></h3>
<p>Given noetic variables <code>x1: &amp;a1, ..., xn: &amp;an</code>, the term <code>box x1, ..., xn { e }</code> copies all the <code>xi</code>s and execute <code>e</code>:</p>
<pre><code class="language-neut">box x1, ..., xn { e }

↓

let x1 = copy-noema(x1) in
...
let xn = copy-noema(xn) in
e
</code></pre>
<h3 id="type-20"><a class="header" href="#type-20">Type</a></h3>
<pre><code class="language-neut">Γ1; ...; Γn; Δ ⊢ e1: a
------------------------------------- (□-intro)
Γ1; ...; Γn, &amp;Δ ⊢ box Δ {e1}: meta a
</code></pre>
<p>where <code>Γ1; ...; Γn</code> is a sequence of contexts.</p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>The body of <code>define</code> is defined to be at layer 0:</p>
<pre><code class="language-neut">define some-function(x: int): int {
  // here is layer 0
  // `x: int` is a variable at layer 0
  add-int(x, 1)
}
</code></pre>
<p>Since <code>box e</code> lifts the layer of <code>e</code>, if we use <code>box</code> at layer 0, the layer of <code>e</code> will become -1:</p>
<pre><code class="language-neut">define use-box(x: int): meta int {
  // here is layer 0
  box {
    // here is layer -1
    10
  }
}
</code></pre>
<p><em>In layer n, we can only use variables at the layer</em>. Thus, the following is not a valid term:</p>
<pre><code class="language-neut">define use-box-error(x: int): meta int {
  // here is layer 0
  box {
    // here is layer -1
    add-int(x, 1) // error: use of a variable at layer 0 (≠ -1)
  }
}
</code></pre>
<p>We can incorporate variables outside <code>box</code> by capturing them:</p>
<pre><code class="language-neut">define use-box-with-noema(x: &amp;int): meta int {
  // here is layer 0
  // x: &amp;int at layer 0
  box x {
    // here is layer -1
    // x: int at layer -1
    add-int(x, 1) // ok
  }
}
</code></pre>
<p>The body of this term is typed as follows:</p>
<pre><code class="language-neut">--------------
x: int ⊢ x: int // layer -1
---------------------------
x: int ⊢ add-int(x, 1): int // layer -1
-------------------------------------------- (□-intro with Δ = (x: int))
· ; x: &amp;int ⊢ box x {add-int(x, 1)}: meta int  // layer 0
</code></pre>
<p>Here, <code>·</code> is the empty context.</p>
<hr />
<p>Incidentally, the rule &quot;The body of <code>define</code> is at layer 0&quot; is not really necessary. We can simply replace the 0 with any integer.</p>
<h3 id="note-14"><a class="header" href="#note-14">Note</a></h3>
<p>&quot;But what after all is the <code>&amp;</code> in <code>&amp;a</code>?&quot; ―Let's give an answer to this question.</p>
<p>Firstly, observe that the following derivation is admissible in Neut:</p>
<pre><code class="language-neut">Γ1; ...; Γn; x: a, Δ ⊢ e: b
-------------------------------- (slide)
Γ1; ...; Γn, x: meta a; Δ ⊢ e: b
</code></pre>
<p>Also, by setting <code>Δ = ·</code> in the typing rule of <code>box</code>, we obtain the following:</p>
<pre><code class="language-neut">Γ1; ...; Γn; · ⊢ e: a
-------------------------------- (□-intro')
Γ1; ...; Γn ⊢ box Δ {e}: meta a
</code></pre>
<p>Thus, we can perform the following derivation:</p>
<pre><code class="language-neut">Γ1; ...; Γn; Δ ⊢ e: a
----------------------------- (slide)
...
----------------------------- (slide)
Γ1; ...; Γn, meta Δ; · ⊢ e: a
-------------------------------------  (□-intro')
Γ1; ...; Γn, meta Δ ⊢ box {e}: meta a
</code></pre>
<p>That is to say, the following rule is admissible without using <code>&amp;</code>:</p>
<pre><code class="language-neut">Γ1; ...; Γn; Δ ⊢ e: a
------------------------------------- (□-intro-slide)
Γ1; ...; Γn, meta Δ ⊢ box {e}: meta a
</code></pre>
<p>Now, compare the above with the rule of <code>box</code>:</p>
<pre><code class="language-neut">Γ1; ...; Γn; Δ ⊢ e: a
------------------------------------- (□-intro)
Γ1; ...; Γn, &amp;Δ ⊢ box Δ {e}: meta a
</code></pre>
<p>As you can see, we can obtain <code>(□-intro)</code> from <code>(□-intro-slide)</code> by replacing <code>meta Δ</code> with <code>&amp;Δ</code>. That is to say, <code>&amp;a</code> is the &quot;structurally-defined&quot; variant of <code>meta a</code>.</p>
<p>If we write <code>meta Δ</code> instead of <code>&amp;Δ</code> in <code>(□-intro)</code>, the rule is equivalent to <code>(□-intro')</code>. By giving the &quot;structural&quot; part a name different from <code>meta</code>, the rule <code>(□-intro)</code> restricts the way how variables in <code>&amp;Δ</code> (which could have been the same as <code>meta Δ</code>) are used.</p>
<p>In this sense, <code>&amp;a</code> is the T-necessity modality defined through structural rules.</p>
<h2 id="letbox"><a class="header" href="#letbox"><code>letbox</code></a></h2>
<p>You can use <code>letbox</code> to &quot;unlift&quot; terms.</p>
<h3 id="example-23"><a class="header" href="#example-23">Example</a></h3>
<pre><code class="language-neut">define roundtrip(x: meta a): meta a {
  // here is layer 0
  box {
    // here is layer -1
    letbox tmp =
      // here is layer 0
      x
    in
    tmp
  }
}

define try-borrowing(x: int): unit {
  // here is layer 0
  // x: int (at layer 0)
  letbox tmp on x =
    // here is layer 1
    // x: &amp;int (at layer 1)
    some-func(x)
  in
  // here is layer 0
  // x: int (at layer 0)
  Unit
}
</code></pre>
<h3 id="syntax-23"><a class="header" href="#syntax-23">Syntax</a></h3>
<pre><code class="language-neut">letbox result = e1 in
e2

letbox result on x1, ..., xn = e1 in
e2
</code></pre>
<h3 id="semantics-23"><a class="header" href="#semantics-23">Semantics</a></h3>
<pre><code class="language-neut">letbox result on x1, ..., xn = e1 in
e2

↓

let x1 = unsafe-cast(a1, &amp;a1, x) in
...
let xn = unsafe-cast(an, &amp;an, xn) in
let result = e1 in
let x1 = unsafe-cast(&amp;a1, a1, x) in
...
let xn = unsafe-cast(&amp;an, an, xn) in
cont
</code></pre>
<h3 id="type-21"><a class="header" href="#type-21">Type</a></h3>
<pre><code class="language-neut">Γ1; ...; Γn, &amp;Δ ⊢ e1: meta a
Γ1; ...; Γn; Δ, Δ', x: a ⊢ e2: b
------------------------------------------------ (□-elim-K)
Γ1; ...; Γn; Δ, Δ' ⊢ letbox x on Δ = e1 in e2: b
</code></pre>
<h3 id="note-15"><a class="header" href="#note-15">Note</a></h3>
<p>Given a term <code>e1</code> at layer n + 1, <code>letbox x = e1 in e2</code> is at layer n:</p>
<pre><code class="language-neut">define roundtrip(x: meta a): meta a {
  box {
    // here is layer -1 (= n)
    letbox tmp =
      // here is layer 0 (= n + 1)
      x
    in
    // here is layer -1 (= n)
    tmp
  }
}
</code></pre>
<p><em>In layer n, we can only use variables at the layer</em>. Thus, the following is not a valid term:</p>
<pre><code class="language-neut">define use-letbox-error(x: meta int): int {
  // here is layer 0
  // x: meta int (at layer 0)
  letbox tmp =
    // here is layer 1
    x // error: use of a variable at layer 0 (≠ 1)
  in
  // here is layer 0
  tmp
}
</code></pre>
<p>We can incorporate variables outside <code>letbox</code> by using <code>on</code>:</p>
<pre><code class="language-neut">define use-letbox(x: int): int {
  // here is layer 0
  // x: int (at layer 0)
  letbox tmp on x =
    // here is layer 1
    // x: &amp;int (at layer 1)
    let _ = x in // ok
    box { Unit }
  in
  // here is layer 0
  10
}
</code></pre>
<h2 id="letbox-t"><a class="header" href="#letbox-t"><code>letbox-T</code></a></h2>
<p>You can use <code>letbox-T</code> to get values from terms of type <code>meta a</code> without changing layers.</p>
<h3 id="example-24"><a class="header" href="#example-24">Example</a></h3>
<pre><code class="language-neut">define extract-value-from-meta(x: meta int): int {
  // here is layer 0
  // x: meta int (at layer 0)
  letbox-T tmp =
    // here is layer 0
    x // ok
  in
  // here is layer 0
  tmp
}
</code></pre>
<h3 id="syntax-24"><a class="header" href="#syntax-24">Syntax</a></h3>
<pre><code class="language-neut">letbox-T result = e1 in
e2

letbox-T result on x1, ..., xn = e1 in
e2
</code></pre>
<h3 id="semantics-24"><a class="header" href="#semantics-24">Semantics</a></h3>
<pre><code class="language-neut">letbox-T result on x1, ..., xn = e1 in
e2

↓

let x1 = unsafe-cast(a1, &amp;a1, x) in
...
let xn = unsafe-cast(an, &amp;an, xn) in
let result = e1 in
let x1 = unsafe-cast(&amp;a1, a1, x) in
...
let xn = unsafe-cast(&amp;an, an, xn) in
cont
</code></pre>
<h3 id="type-22"><a class="header" href="#type-22">Type</a></h3>
<pre><code class="language-neut">Γ1; ...; Γn, &amp;Δ ⊢ e1: meta a
Γ1; ...; Γn, Δ, Δ', x: a ⊢ e2: b
-------------------------------------------------- (□-elim-T)
Γ1; ...; Γn, Δ, Δ' ⊢ letbox-T x on Δ = e1 in e2: b
</code></pre>
<p>Note that the layer of <code>e1</code>, <code>e2</code>, <code>letbox-T (..)</code> are the same.</p>
<h3 id="note-16"><a class="header" href="#note-16">Note</a></h3>
<p><code>letbox-T</code> doesn't alter layers:</p>
<pre><code class="language-neut">define extract-value-from-meta(x: meta int): int {
  // here is layer 0
  letbox-T tmp =
    // here is layer 0
    x
  in
  // here is layer 0
  tmp
}
</code></pre>
<p><code>on</code> doesn't alter the layers of variables, too:</p>
<pre><code class="language-neut">define extract-value-from-meta(x: int): int {
  // here is layer 0
  // x: int (at layer 0)
  letbox-T tmp on x =
    // here is layer 0
    // x: &amp;int (at layer 0)
    x
  in
  // here is layer 0
  // x: int (at layer 0)
  tmp
}
</code></pre>
<h2 id="case"><a class="header" href="#case"><code>case</code></a></h2>
<p>You can use <code>case</code> to inspect noetic ADT values or integers.</p>
<h3 id="example-25"><a class="header" href="#example-25">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define foo-noetic(n: &amp;my-nat): int {
  case n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    // the type of foo-noetic is `(&amp;my-nat) -&gt; int`
    foo-noetic(m)
  }
}
</code></pre>
<h3 id="syntax-25"><a class="header" href="#syntax-25">Syntax</a></h3>
<pre><code class="language-neut">case e1, ..., en {
| pattern-1 =&gt;
  body-1
  ...
| pattern-m =&gt;
  body-m
}
</code></pre>
<h3 id="semantics-25"><a class="header" href="#semantics-25">Semantics</a></h3>
<p>The semantics of <code>case</code> is the same as <code>match</code>, except that <code>case</code> doesn't consume ADT values.</p>
<h3 id="type-23"><a class="header" href="#type-23">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a1
...
Γ ⊢ en: an

Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ pat-1: a1
Γ, arg_{1,1}: &amp;t_{1,1}, ..., arg_{1, k_{1}}: &amp;t{1, k_{1}} ⊢ body-1: b

...

Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ pat-m: an
Γ, arg_{m,1}: &amp;t_{m,1}, ..., arg_{m, k_{m}}: &amp;t{m, k_{m}} ⊢ body-m: b

(for all i = 1, ..., m, pat-i is a pattern for e1, ..., en)
(the sequence pat-1, ..., pat-m is a exhaustinve matching against e1, ..., en)
------------------------------------------------------------------------------
Γ ⊢ case e1, ..., en {
    | pat-1 =&gt; body-1
    ...
    | pat-m =&gt; body-m
    }: b
</code></pre>
<h3 id="note-17"><a class="header" href="#note-17">Note</a></h3>
<p>An example of the application of the typing rule of <code>case</code>:</p>
<pre><code class="language-neut">Γ ⊢ n: &amp;my-nat

Γ ⊢ Zero: my-nat // pat-1
Γ ⊢ 100: int // body-1

Γ, m: my-nat ⊢ Succ(m): my-nat // pat-2
Γ, m: &amp;my-nat ⊢ foo-noetic(m): int // body-2

(Zero and Succ(m) are patterns for n)
(the sequence Zero, Succ(m) is a exhaustinve matching against n)
------------------------------------------------------------------------------
Γ ⊢ case n {
    | Zero =&gt; 100
    | Succ(m) =&gt; foo-noetic(m)
    }: int
</code></pre>
<h2 id="thread-1"><a class="header" href="#thread-1"><code>thread</code></a></h2>
<p>A <code>thread</code> in Neut is the type of a thread (much like promises in other languages).</p>
<h3 id="example-26"><a class="header" href="#example-26">Example</a></h3>
<pre><code class="language-neut">thread(int) // the type of a thread that returns int

thread((int) -&gt; bool) // the type of a thread that returns (int) -&gt; bool
</code></pre>
<h3 id="syntax-26"><a class="header" href="#syntax-26">Syntax</a></h3>
<pre><code class="language-neut">thread(t)
</code></pre>
<h3 id="semantics-26"><a class="header" href="#semantics-26">Semantics</a></h3>
<p>For any type <code>t</code>, the type <code>thread(t)</code> is compiled into a pointer to a closed function that discards and copies the values of the type in the following manner:</p>
<ul>
<li>Discard <code>e: thread(t)</code>: Waits the thread <code>e</code> to finish and discard the result along the type <code>t</code>, and then returns 0</li>
<li>Copy <code>e: thread(t)</code>: Waits the thread <code>e</code> to finish, copies the result along the type <code>t</code>, creates an already-finished thread, and returns it as a clone.</li>
</ul>
<p>The type <code>t</code> is inside the internal representation of a term <code>e: thread(t)</code>. Because of that, for any <code>t</code>, <code>thread(t)</code> is compiled to the same closed function. For more, see the following Note.</p>
<h3 id="type-24"><a class="header" href="#type-24">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: type
----------------
Γ ⊢ thread(t): type
</code></pre>
<h3 id="note-18"><a class="header" href="#note-18">Note</a></h3>
<p>(1) The internal representation of <code>e: thread(t)</code> is a &quot;3-word + 1-byte&quot; tuple like the below:</p>
<pre><code class="language-neut">   (thread-id, t, result-value-or-none, finished)
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^
//  3-word                              1-byte
</code></pre>
<p>When a thread is created,</p>
<ul>
<li>the value of <code>result-value-or-none</code> is initialized to 0, and</li>
<li>the value of <code>finished</code> is also initialized to 0.</li>
</ul>
<p>When a thread is completed,</p>
<ul>
<li>the value <code>result-value-or-none</code> is updated to the result of the thread, and</li>
<li>the value <code>finished</code> is updated to 1.</li>
</ul>
<p>(2) As you can see from the semantics, you must use threads linearly to perform parallel computation.</p>
<p>(3) A thread in Neut is a thin layer over pthread.</p>
<h2 id="detach"><a class="header" href="#detach"><code>detach</code></a></h2>
<p>You can use <code>detach</code> to create a new thread.</p>
<h3 id="example-27"><a class="header" href="#example-27">Example</a></h3>
<pre><code class="language-neut">define foo(): thread(int) {
  detach {
    print(&quot;fA&quot;);
    1
  }
}

define bar(): thread(int) {
  let f =
    detach {
      print(&quot;fA&quot;);
      1
    }
  in
  whatever();
  f
}
</code></pre>
<h3 id="syntax-27"><a class="header" href="#syntax-27">Syntax</a></h3>
<pre><code class="language-neut">detach {
  e
}
</code></pre>
<h3 id="semantics-27"><a class="header" href="#semantics-27">Semantics</a></h3>
<p><code>detach { e }</code> creates a new thread and starts computation of <code>e</code> in that thread.</p>
<h3 id="type-25"><a class="header" href="#type-25">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: a
-------------------------
Γ ⊢ detach { e }: thread(a)
</code></pre>
<h3 id="note-19"><a class="header" href="#note-19">Note</a></h3>
<ul>
<li><code>detach</code> internally uses pthread.</li>
</ul>
<h2 id="attach"><a class="header" href="#attach"><code>attach</code></a></h2>
<p>You can use <code>detach</code> to wait for a thread and get its result.</p>
<h3 id="example-28"><a class="header" href="#example-28">Example</a></h3>
<pre><code class="language-neut">define foo(f: thread(int)): int {
  attach { f }
}

define bar(f: thread((int) -&gt; bool)): bool {
  let k = attach { f } in
  k(100)
}
</code></pre>
<h3 id="syntax-28"><a class="header" href="#syntax-28">Syntax</a></h3>
<pre><code class="language-neut">attach { e }
</code></pre>
<h3 id="semantics-28"><a class="header" href="#semantics-28">Semantics</a></h3>
<p><code>attach</code> waits given thread to finish and gets its resulting value.</p>
<p>It also <code>free</code>s the 3-word + 1-byte tuple that represents a thread after getting the result.</p>
<h3 id="type-26"><a class="header" href="#type-26">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: thread(a)
-------------------
Γ ⊢ attach { e }: a
</code></pre>
<h3 id="note-20"><a class="header" href="#note-20">Note</a></h3>
<ul>
<li><code>attach</code> internally uses pthread.</li>
</ul>
<h2 id="quote"><a class="header" href="#quote"><code>quote</code></a></h2>
<p>You can use <code>quote</code> to wrap the types of &quot;safe&quot; values by <code>meta {..}</code>.</p>
<h3 id="example-29"><a class="header" href="#example-29">Example</a></h3>
<pre><code class="language-neut">define quote-int(x: int): meta int {
  quote {x}
}

define quote-bool(x: bool): meta bool {
  quote {x}
}

define quote-function(f: (int) -&gt; bool): meta (int) -&gt; bool {
  quote {f} // error; won't typecheck
}
</code></pre>
<h3 id="syntax-29"><a class="header" href="#syntax-29">Syntax</a></h3>
<pre><code class="language-neut">quote {e}
</code></pre>
<h3 id="semantics-29"><a class="header" href="#semantics-29">Semantics</a></h3>
<pre><code class="language-neut">quote {e}

↓

e
</code></pre>
<h3 id="type-27"><a class="header" href="#type-27">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: a
(a is an &quot;actual&quot; type)
-----------------------
Γ ⊢ quote {e}: meta a
</code></pre>
<p>Here, an &quot;actual&quot; type is a type that satisfies all the following conditions:</p>
<ul>
<li>It doesn't contain any free variables</li>
<li>It doesn't contain any noetic types</li>
<li>It doesn't contain any function types</li>
<li>It doesn't contain any &quot;dubious&quot; ADTs</li>
</ul>
<p>Here, a &quot;dubious&quot; ADT is something like the below:</p>
<pre><code class="language-neut">// the type `joker-x` is dubious since it contains a noetic argument
data joker-x {
| Joker-X(&amp;list(int))
}

// the type `joker-y` is dubious since it contains a functional argument
data joker-y {
| Joker-Y(int -&gt; bool)
}

// the type `joker-z` is dubious since it contains a dubious ADT argument
data joker-z {
| Joker-Z(joker-y)
}
</code></pre>
<h3 id="note-21"><a class="header" href="#note-21">Note</a></h3>
<p>(1) Unlike <code>box</code>, <code>quote</code> doesn't alter layers.</p>
<p>(2) <code>quote</code> doesn't add extra expressiveness to the type system. For example, <code>quote</code> on <code>bool</code> can be replaced with <code>box</code> as follows:</p>
<pre><code class="language-neut">define quote-bool(b: bool): meta bool {
  quote {b}
}

↓

define quote-bool(b: bool): meta bool {
  if b {
    box {True}
  } else {
    box {False}
  }
}
</code></pre>
<p><code>quote</code> on <code>either(bool, unit)</code> can also be replaced with <code>box</code> as follows:</p>
<pre><code class="language-neut">define quote-either(x: either(bool, unit)): meta either(bool, unit) {
  quote {b}
}

↓

define quote-either(x: either(bool, unit)): meta either(bool, unit) {
  match x {
  | Left(b) =&gt;
    if b {
      box {Left(True)}
    } else {
      box {Left(False)}
    }
  | Right(u) =&gt;
    box {Right(Unit)}
  }
}
</code></pre>
<p><code>quote</code> is there only for convenience.</p>
<h2 id="magic"><a class="header" href="#magic"><code>magic</code></a></h2>
<p>You can use <code>magic</code> to perform weird stuff. Using <code>magic</code> is an unsafe operation.</p>
<h3 id="example-30"><a class="header" href="#example-30">Example</a></h3>
<pre><code class="language-neut">// empty type
data descriptor {}

// add an element to the empty type
inline stdin: descriptor {
  magic cast(int, descriptor, 0) // 🌟 cast
}

define malloc-then-free(): unit {
  // allocates memory region (stack)
  let ptr = magic alloca(int64, 2) in // allocates (64 / 8) * 2 = 16 byte

  // allocates memory region (heap)
  let size: int = 10 in
  let ptr: pointer = magic external malloc(size) in // 🌟 external

  // stores a value
  let value: int = 123 in
  magic store(int, value, ptr); // 🌟 store

  // loads and print a value
  let value = magic load(int, ptr) in // 🌟 load
  print-int(value); // =&gt; 123

  // tells the compiler to treat the content of {..} as a value
  let v =
    magic opaque-value {
      get-some-c-constant-using-FFI()
    }
  in

  // frees the pointer and return
  magic external free(ptr); // 🌟 external
  Unit
}

</code></pre>
<h3 id="syntax-30"><a class="header" href="#syntax-30">Syntax</a></h3>
<pre><code class="language-neut">magic cast(from-type, to-type, value)

magic store(lowtype, stored-value, address)

magic load(lowtype, address)

magic alloca(lowtype, num-of-elems)

magic opaque-value { e }

magic external func-name(e1, ..., en)

magic external func-name(e1, ..., en)(vararg-1: lowtype-1, ..., vararg-n: lowtype-n)
</code></pre>
<p>A &quot;lowtype&quot; is a term that reduces to one of the following:</p>
<ul>
<li><code>int1</code>, <code>int2</code>, ..., <code>int64</code></li>
<li><code>float16</code>, <code>float32</code>, <code>float64</code></li>
<li><code>pointer</code></li>
</ul>
<p>You can also use <code>int</code> and <code>float</code> as a lowtype. These are just syntax sugar for <code>int64</code> and <code>float64</code>, respectively.</p>
<h3 id="semantics-30"><a class="header" href="#semantics-30">Semantics</a></h3>
<p><code>magic cast (a, b, e)</code> casts the term <code>e</code> from the type <code>a</code> to <code>b</code>. <code>cast</code> does nothing at runtime.</p>
<p><code>magic store(lowtype, value, address)</code> stores a value <code>value</code> to <code>address</code>. This is the same as <code>store</code> <a href="https://llvm.org/docs/LangRef.html#store-instruction">in LLVM</a>.</p>
<p><code>magic load(lowtype, address)</code> loads a value from <code>address</code>. This is the same as <code>load</code> <a href="https://llvm.org/docs/LangRef.html#load-instruction">in LLVM</a>.</p>
<p><code>magic alloca(lowtype, num-of-elems)</code> allocates memory region on the stack frame. This is the same as <code>alloca</code> <a href="https://llvm.org/docs/LangRef.html#alloca-instruction">in LLVM</a>.</p>
<p><code>magic opaque-value { e }</code> tells the compiler to treat the term <code>e</code> as a value. You may want to use this in combination with <code>define</code> or <code>inline</code> that don't have any explicit arguments.</p>
<p><code>magic external func(e1, ..., en)</code> can be used to call foreign functions (or FFI). See <a href="./statements.html#foreign">foreign in Statements</a> for more information.</p>
<p><code>magic external func(e1, ..., en)(e{n+1}: lowtype1, ..., e{n+m}: lowtypem)</code> can also be used to call variadic foreign functions like printf in C. A use of such varidic <code>external</code> can be found in the core library <a href="https://github.com/vekatze/neut-core/blob/6ef2fed68a6b0b063e15350e788c82ea9371f6bb/source/text/io.nt#L43">here</a>.</p>
<h3 id="type-28"><a class="header" href="#type-28">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t1: type
Γ ⊢ t2: type
Γ ⊢ e: t1
-----------------------------
Γ ⊢ magic cast(t1, t2, e): t2


(t is a lowtype)
Γ ⊢ stored-value: t
Γ ⊢ address: pointer
------------------------------------------------------
Γ ⊢ magic store(t, stored-value, address): unit


(t is a lowtype)
Γ ⊢ t: type
Γ ⊢ address: pointer
------------------------------------------------------
Γ ⊢ magic load(t, address): t

Γ ⊢ e:t
------------------------------------------------------
Γ ⊢ magic opaque-value { e }: t


Γ ⊢ e1: t1
...
Γ ⊢ en: tn
Γ ⊢ t: type
(t1 is a lowtype)
...
(tn is a lowtype)
(t is a lowtype or void)
(func is a foreign function)
--------------------------------------------------
Γ ⊢ magic external func(e1, ..., en): t


Γ ⊢ e1: t1
...
Γ ⊢ en: tn
Γ ⊢ e{n+1}: t{n+1}
...
Γ ⊢ e{n+m}: t{n+m}
Γ ⊢ t: type
(t1 is a lowtype)
...
(tm is a lowtype)
(t is a lowtype or void)
(func is a foreign function)
---------------------------------------------------------------------------------
Γ ⊢ magic external func(e1, ..., en)(e{n+1}: t{n+1}, ..., e{n+m}: t{n+m}): t
</code></pre>
<h2 id="introspect"><a class="header" href="#introspect"><code>introspect</code></a></h2>
<p>You can use <code>introspect key {..}</code> to introspect the compiler's configuration.</p>
<h3 id="example-31"><a class="header" href="#example-31">Example</a></h3>
<pre><code class="language-neut">define arch-dependent-constant(): int {
  introspect architecture {
  | arm64 =&gt;
    1
  | amd64 =&gt;
    2
  }
}

define os-dependent-constant(): int {
  introspect operating-system {
  | linux =&gt;
    1
  | default =&gt;
    // `2` is returned if target-os != linux
    2
  }
}
</code></pre>
<h3 id="syntax-31"><a class="header" href="#syntax-31">Syntax</a></h3>
<pre><code class="language-neut">introspect key {
| value-1 =&gt;
  e1
  ...
| value-n =&gt;
  en
}
</code></pre>
<p>You can use the following configuration <code>key</code>s and configuration <code>value</code>s:</p>
<div class="table-wrapper"><table><thead><tr><th>Configuration Key</th><th>Configuration Value</th></tr></thead><tbody>
<tr><td><code>architecture</code></td><td><code>amd64</code> or <code>arm64</code></td></tr>
<tr><td><code>operating-system</code></td><td><code>linux</code> or <code>darwin</code></td></tr>
<tr><td><code>build-mode</code></td><td><code>develop</code> or <code>release</code></td></tr>
</tbody></table>
</div>
<p>You can also use <code>default</code> as a configuration value to represent a fallback case.</p>
<h3 id="semantics-31"><a class="header" href="#semantics-31">Semantics</a></h3>
<p>Firstly, <code>introspect key {v1 =&gt; e1 | ... | vn =&gt; en}</code> looks up the configuration value <code>v</code> of the compiler by <code>key</code>. Then it reads the configuration values <code>v1</code>, ..., <code>vn</code> in this order to find <code>vk</code> that is equal to the <code>v</code>. If such a <code>vk</code> is found, <code>introspect</code> executes the corresponding clause <code>ek</code>. If no such <code>vk</code> is found, <code>introspect</code> will report a compilation error.</p>
<p>The configuration value <code>default</code> is equal to any configuration values.</p>
<h3 id="type-29"><a class="header" href="#type-29">Type</a></h3>
<pre><code class="language-neut">(key is a configuration key)

(v1 is a configuration value)
Γ ⊢ e1: a

...

(vn is a configuration value)
Γ ⊢ en: a
------------------------------------------
Γ ⊢ introspect key {
    | v1 =&gt; e1
      ...
    | vn =&gt; en
    }: a
</code></pre>
<h3 id="note-22"><a class="header" href="#note-22">Note</a></h3>
<ul>
<li>The branching of an <code>introspect</code> is resolved at compile-time.</li>
</ul>
<h2 id="include-text"><a class="header" href="#include-text"><code>include-text</code></a></h2>
<p>You can use <code>include-text</code> to embed the content of a static file into a source file at compile time.</p>
<h3 id="example-32"><a class="header" href="#example-32">Example</a></h3>
<pre><code class="language-neut">import {
  static {some-file}
}

define use-some-file(): unit {
  let t &amp;text = include-text(some-file) in
  print(t)
}
</code></pre>
<h3 id="syntax-32"><a class="header" href="#syntax-32">Syntax</a></h3>
<pre><code class="language-neut">include-text(key)
</code></pre>
<h3 id="sematics"><a class="header" href="#sematics">Sematics</a></h3>
<p>The compiler expands <code>include-text(foo)</code> into the content of <code>foo</code> at compile time.</p>
<p>If <code>foo</code> isn't a key of a UTF-8 file, <code>include-text(foo)</code> reports a compilation error.</p>
<h3 id="type-30"><a class="header" href="#type-30">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)    (k is a static file's key)
----------------------------------------------
Γ ⊢ include-text(k): &amp;text
</code></pre>
<h3 id="note-23"><a class="header" href="#note-23">Note</a></h3>
<p>You may also want to read <a href="modules.html#static">the section on static files in Modules</a>.</p>
<h2 id="admit-1"><a class="header" href="#admit-1"><code>admit</code></a></h2>
<p>You can use <code>admit</code> to suppress the type checker and sketch the structure of your program.</p>
<h3 id="example-33"><a class="header" href="#example-33">Example</a></h3>
<pre><code class="language-neut">define my-complex-function(): unit {
  admit
}
</code></pre>
<h3 id="syntax-33"><a class="header" href="#syntax-33">Syntax</a></h3>
<pre><code class="language-neut">admit
</code></pre>
<h3 id="sematics-1"><a class="header" href="#sematics-1">Sematics</a></h3>
<p>Evaluating <code>admit</code> will exit the program, displaying a message like the following:</p>
<pre><code class="language-text">admit: /path/to/file.nt:1:2
</code></pre>
<p>When <code>admit</code> exits a program, the exit code is 1.</p>
<h3 id="type-31"><a class="header" href="#type-31">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: type
------------
Γ ⊢ admit: t
</code></pre>
<h3 id="note-24"><a class="header" href="#note-24">Note</a></h3>
<ul>
<li><code>admit</code> is the <code>undefined</code> in Haskell.</li>
<li><code>admit</code> is intended to be used ephemerally during development.</li>
</ul>
<h2 id="assert-1"><a class="header" href="#assert-1"><code>assert</code></a></h2>
<p>You can use <code>assert</code> to ensure that a condition is satisfied at run-time.</p>
<h3 id="example-34"><a class="header" href="#example-34">Example</a></h3>
<pre><code class="language-neut">define fact(n: int): int {
  assert &quot;the input must be non-negative&quot; {
    ge-int(n, 0)
  };
  if eq-int(n, 0) {
    1
  } else {
    mul-int(n, fact(sub-int(n, 1)))
  }
}
</code></pre>
<h3 id="syntax-34"><a class="header" href="#syntax-34">Syntax</a></h3>
<pre><code class="language-neut">assert &quot;any-string&quot; {
  e
}
</code></pre>
<h3 id="semantics-32"><a class="header" href="#semantics-32">Semantics</a></h3>
<p>If the <a href="./commands.html#--mode">build mode</a> is <code>release</code>, <code>assert</code> does nothing.</p>
<p>Otherwise, <code>assert &quot;description&quot; { condition }</code> evaluates <code>condition</code> and checks if it is <code>True</code>. If it is <code>True</code>, the <code>assert</code> simply evaluates to <code>Unit</code>. Otherwise, it reports that the assertion <code>&quot;description&quot;</code> failed and exits the execution of the program with the exit code <code>1</code>.</p>
<h3 id="type-32"><a class="header" href="#type-32">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ condition: bool
--------------------------------------------
Γ ⊢ assert &quot;description&quot; { condition }: unit
</code></pre>
<h2 id="_"><a class="header" href="#_"><code>_</code></a></h2>
<p><code>_</code> is a hole that must be inferred by the type checker.</p>
<h3 id="example-35"><a class="header" href="#example-35">Example</a></h3>
<pre><code class="language-neut">define id(a: type, x: a): a {
  x
}

define use-hole(): unit {
  id(_, Unit) // ← using a hole (inferred to be `unit`)
}
</code></pre>
<h3 id="syntax-35"><a class="header" href="#syntax-35">Syntax</a></h3>
<pre><code class="language-neut">_
</code></pre>
<h3 id="semantics-33"><a class="header" href="#semantics-33">Semantics</a></h3>
<p><code>_</code> is a hole that must be inferred by the type checker. If the type checker resolves a hole into a term <code>e</code>, this hole behaves the same as <code>e</code>. If the type checker can't resolve a hole, the type checker reports a compilation error.</p>
<h3 id="type-33"><a class="header" href="#type-33">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e[tmp := e1]: a
-------------------
Γ ⊢ e[tmp := _]: a
</code></pre>
<h3 id="note-25"><a class="header" href="#note-25">Note</a></h3>
<p>Please do not confuse a hole with the <code>_</code> in <code>let _ = e1 in e2</code>.</p>
<h2 id="on"><a class="header" href="#on"><code>on</code></a></h2>
<p><code>let x on y = e1 in e2</code> can be used to introduce noetic values in a specific scope.</p>
<h3 id="example-36"><a class="header" href="#example-36">Example</a></h3>
<pre><code class="language-neut">define play-with-let-on(): unit {
  let xs: list(int) = [1, 2, 3] in
  let len on xs =
    // the type of `xs` is `&amp;list(int)` here
    length(xs)
  in
  // the type of `xs` is `list(int)` here
  print-int(len)
}
</code></pre>
<h3 id="syntax-36"><a class="header" href="#syntax-36">Syntax</a></h3>
<pre><code class="language-neut">let y on x1, ..., xn = e1 in
e2
</code></pre>
<h3 id="semantics-34"><a class="header" href="#semantics-34">Semantics</a></h3>
<pre><code class="language-neut">let result on x1, ..., xn = e1 in
e2

// ↓ desugar

letbox-T result on x1, ..., xn = quote {e1} in
e2
</code></pre>
<h3 id="type-34"><a class="header" href="#type-34">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="e"><a class="header" href="#e"><code>*e</code></a></h2>
<p>You can use <code>*e</code> to create a non-noetic value from a noetic value.</p>
<h3 id="example-37"><a class="header" href="#example-37">Example</a></h3>
<pre><code class="language-neut">define clone-list&lt;a&gt;(xs: &amp;list(a)): list(a) {
  case xs {
  | Nil =&gt;
    Nil
  | Cons(y, ys) =&gt;
    Cons(*y, clone-list(ys))
  }
}
</code></pre>
<h3 id="syntax-37"><a class="header" href="#syntax-37">Syntax</a></h3>
<pre><code class="language-neut">*e
</code></pre>
<h3 id="semantics-35"><a class="header" href="#semantics-35">Semantics</a></h3>
<pre><code class="language-neut">*e

↓

embody(e)
</code></pre>
<p>where the function <code>embody</code> is defined in the core library as follows:</p>
<pre><code class="language-neut">// core.box

// □A -&gt; A (Axiom T)
inline axiom-T&lt;a&gt;(x: meta a): a {
  letbox-T x' = x in
  x'
}

inline embody&lt;a&gt;(x: &amp;a): a {
  axiom-T(box x {x}) // ← this `box` copies the hyle of `x`
}
</code></pre>
<h3 id="type-35"><a class="header" href="#type-35">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-26"><a class="header" href="#note-26">Note</a></h3>
<p>Intuitively, given a noema <code>e: &amp;a</code>, <code>*e: a</code> is a clone of the hyle of the noema.</p>
<p>This clone is created by copying the hyle along the type <code>t</code>.</p>
<p>The original hyle is kept intact.</p>
<h2 id="use-e-x1--xn-in-cont"><a class="header" href="#use-e-x1--xn-in-cont"><code>use e {x1, ..., xn} in cont</code></a></h2>
<p>You can use <code>use e {x1, ..., xn} in cont</code> as a shorthand to destructure an ADT that has only one constructor.</p>
<h3 id="example-38"><a class="header" href="#example-38">Example</a></h3>
<pre><code class="language-neut">data config {
| Config(
    path: &amp;text,
    count: int,
  )
}

define use-config(c: config): unit {
  use c {count} in
  print-int(count)
}

// cf.
define use-config-2(c: config): unit {
  let Config of {count} = c in
  print-int(count)
}
</code></pre>
<h3 id="syntax-38"><a class="header" href="#syntax-38">Syntax</a></h3>
<pre><code class="language-neut">use e {x1, ..., xn} in
cont
</code></pre>
<h3 id="semantics-36"><a class="header" href="#semantics-36">Semantics</a></h3>
<p><code>use</code> is the following syntax sugar:</p>
<pre><code class="language-neut">use e {x1, ..., xn} in
cont

↓

let K of {x1, ..., xn} = e in
cont
</code></pre>
<p>Here, the <code>K</code> is the only constructor of the type of <code>e</code>. If the type of e contains more than one constructor, <code>use</code> results in a compilation error.</p>
<h3 id="type-36"><a class="header" href="#type-36">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="ex"><a class="header" href="#ex"><code>e::x</code></a></h2>
<p>You can use <code>e::x</code> to extract a value from an ADT value.</p>
<h3 id="example-39"><a class="header" href="#example-39">Example</a></h3>
<pre><code class="language-neut">data config {
| Config(
    path: &amp;text,
    count: int,
  )
}

define use-config(c: config): unit {
  print-int(c::count)
}
</code></pre>
<h3 id="syntax-39"><a class="header" href="#syntax-39">Syntax</a></h3>
<pre><code class="language-neut">e::x
</code></pre>
<h3 id="semantics-37"><a class="header" href="#semantics-37">Semantics</a></h3>
<p><code>::</code> is the following syntax sugar:</p>
<pre><code class="language-neut">e::x

↓

use e {x} in
x
</code></pre>
<h3 id="type-37"><a class="header" href="#type-37">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-27"><a class="header" href="#note-27">Note</a></h3>
<p>One possible use of <code>::</code> is to select a function from a record of functions:</p>
<pre><code class="language-neut">// dictionary.nt ---------------------------------

...

// declare a record of functions (like signatures in OCaml)
data trope(k) {
| Trope(
    insert: &lt;v&gt;(k, v, dictionary(k, v)) -&gt; dictionary(k, v),
    lookup: &lt;v&gt;(&amp;k, &amp;dictionary(k, v)) -&gt; ?&amp;v,
    delete: &lt;v&gt;(k, dictionary(k, v)) -&gt; dictionary(k, v),
  )
}

// foo.nt ----------------------------------

import {
  Dict,
  ...
}

// create a record of functions
inline intdict: Dict.trope(int) {
  // ... whatever ...
}

// ... and use a function of the record
define make-big-dict(): dictionary(int, int) {
  loop(700000, Dict.empty(), function (acc, _) {
    let key = random(1000000) in
    let val = random(1000000) in
    intdict::insert(key, val, acc) // 🌟
  })
}
</code></pre>
<p>You can find a working example of such a use case <a href="https://github.com/vekatze/neut-core/blob/main/source/bench/random-dict.nt">in the core library</a>.</p>
<h2 id="if"><a class="header" href="#if"><code>if</code></a></h2>
<p>You can use <code>if</code> as in other languages.</p>
<h3 id="example-40"><a class="header" href="#example-40">Example</a></h3>
<pre><code class="language-neut">define foo(b1: bool): unit {
  if b1 {
    print(&quot;hey&quot;)
  } else {
    print(&quot;yo&quot;)
  }
}

define bar(b1: bool, b2: bool): unit {
  let tmp =
    if b1 {
      &quot;hey&quot;
    } else-if b2 {
      &quot;yo&quot;
    } else {
      &quot;pohe&quot;
    }
  in
  print(tmp)
}
</code></pre>
<h3 id="syntax-40"><a class="header" href="#syntax-40">Syntax</a></h3>
<pre><code class="language-neut">if b1 { e1 } else-if b2 { e2 }  ... else-if b_{n-1} { e_{n-1} } else { en }
</code></pre>
<h3 id="semantics-38"><a class="header" href="#semantics-38">Semantics</a></h3>
<p><code>if</code> is the following syntax sugar:</p>
<pre><code class="language-neut">if b1 { e1 } else-if b2 { e2 }  ... else-if b_{n-1} { e_{n-1} } else { en }

↓

match b1 {
| True =&gt; e1
| False =&gt;
  match b2 {
  | True =&gt; e2
  | False =&gt;
    ...
    match b_{n-1} {
    | True =&gt; e_{n-1}
    | False =&gt; en
    }
  }
}
</code></pre>
<h3 id="type-38"><a class="header" href="#type-38">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="when-cond--e-"><a class="header" href="#when-cond--e-"><code>when cond { e }</code></a></h2>
<p>You can use <code>when cond { e }</code> to perform <code>e</code> only when <code>cond</code> is true.</p>
<h3 id="example-41"><a class="header" href="#example-41">Example</a></h3>
<pre><code class="language-neut">define foo(b1: bool): unit {
  when b1 {
    print(&quot;hey&quot;)
  }
}

</code></pre>
<h3 id="syntax-41"><a class="header" href="#syntax-41">Syntax</a></h3>
<pre><code class="language-neut">when cond {
  e
}
</code></pre>
<h3 id="semantics-39"><a class="header" href="#semantics-39">Semantics</a></h3>
<p><code>when</code> is the following syntax sugar:</p>
<pre><code class="language-neut">when cond {
  e
}

↓

if cond {
  e
} else {
  Unit
}
</code></pre>
<h3 id="type-39"><a class="header" href="#type-39">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="e1-e2"><a class="header" href="#e1-e2"><code>e1; e2</code></a></h2>
<p>You can use <code>e1; e2</code> to perform sequential operations.</p>
<h3 id="example-42"><a class="header" href="#example-42">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  print(&quot;hello&quot;);
  print(&quot;, &quot;);
  print(&quot;world!&quot;);
  print(&quot;\n&quot;)
}
</code></pre>
<h3 id="syntax-42"><a class="header" href="#syntax-42">Syntax</a></h3>
<pre><code class="language-neut">e1;
e2
</code></pre>
<h3 id="semantics-40"><a class="header" href="#semantics-40">Semantics</a></h3>
<p><code>e1; e2</code> is the following syntax sugar:</p>
<pre><code class="language-neut">let _: unit = e1 in
e2
</code></pre>
<h3 id="type-40"><a class="header" href="#type-40">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="try-x--e1-in-e2"><a class="header" href="#try-x--e1-in-e2"><code>try x = e1 in e2</code></a></h2>
<p><code>try</code> is a shorthand for <code>match</code> + <code>either</code>.</p>
<h3 id="example-43"><a class="header" href="#example-43">Example</a></h3>
<pre><code class="language-neut">define get-value-or-fail(): either(error, int) {
  // .. whatever ..
}

define foo(): unit {
  try x1 = get-value-or-fail() in
  try x2 = get-value-or-fail() in
  print-int(add-int(x1, x2))
}
</code></pre>
<h3 id="syntax-43"><a class="header" href="#syntax-43">Syntax</a></h3>
<pre><code class="language-neut">try x = e1 in
e2
</code></pre>
<h3 id="semantics-41"><a class="header" href="#semantics-41">Semantics</a></h3>
<p><code>try x = e1 in e2</code> is a shorthand of the below:</p>
<pre><code class="language-neut">match e1 {
| Left(err) =&gt;
  Left(err)
| Right(x) =&gt;
  e2
}
</code></pre>
<h3 id="type-41"><a class="header" href="#type-41">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-28"><a class="header" href="#note-28">Note</a></h3>
<p>The definition of <code>either</code> is as follows:</p>
<pre><code class="language-neut">data either(a, b) {
| Left(a)
| Right(b)
}
</code></pre>
<h2 id="tie-x--e1-in-e2"><a class="header" href="#tie-x--e1-in-e2"><code>tie x = e1 in e2</code></a></h2>
<p>You can use <code>tie</code> as a &quot;noetic&quot; <code>let</code>.</p>
<h3 id="example-44"><a class="header" href="#example-44">Example</a></h3>
<pre><code class="language-neut">data config {
| Config(
    foo: int,
    bar: bool,
  )
}

define use-noetic-config(c: &amp;config): int {
  tie Config of {foo} = c in
  *foo
}
</code></pre>
<h3 id="syntax-44"><a class="header" href="#syntax-44">Syntax</a></h3>
<pre><code class="language-neut">tie x = e1 in
e2
</code></pre>
<h3 id="semantics-42"><a class="header" href="#semantics-42">Semantics</a></h3>
<p><code>tie x = e1 in e2</code> is a shorthand of the below:</p>
<pre><code class="language-neut">case e1 {
| x =&gt;
  e2
}
</code></pre>
<h3 id="type-42"><a class="header" href="#type-42">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="pin-x--e1-in-e2"><a class="header" href="#pin-x--e1-in-e2"><code>pin x = e1 in e2</code></a></h2>
<p>You can use <code>pin</code> to create a value and use it as a noema.</p>
<h3 id="example-45"><a class="header" href="#example-45">Example</a></h3>
<pre><code class="language-neut">// before
define foo(): unit {
  let xs = make-list(123) in
  let result on xs = some-func(xs) in
  let _ = xs in
  result
}

↓

// after
define foo(): unit {
  pin xs = make-list(123) in
  some-func(xs)
}
</code></pre>
<h3 id="syntax-45"><a class="header" href="#syntax-45">Syntax</a></h3>
<pre><code class="language-neut">pin x = e1 in
e2
</code></pre>
<h3 id="semantics-43"><a class="header" href="#semantics-43">Semantics</a></h3>
<pre><code class="language-neut">pin x = e1 in
e2

↓

let x = e1 in
let tmp on x = e2 in
let _ = x in
tmp
</code></pre>
<h2 id="t"><a class="header" href="#t"><code>?t</code></a></h2>
<p>You can use <code>?t</code> to represent an optional type.</p>
<h3 id="example-46"><a class="header" href="#example-46">Example</a></h3>
<pre><code class="language-neut">define foo(x: int): ?int {
  if eq-int(x, 0) {
    Right(100)
  } else {
    Left(Unit)
  }
}
</code></pre>
<h3 id="syntax-46"><a class="header" href="#syntax-46">Syntax</a></h3>
<pre><code class="language-neut">?t
</code></pre>
<h3 id="semantics-44"><a class="header" href="#semantics-44">Semantics</a></h3>
<p><code>?t</code> is the following syntax sugar:</p>
<pre><code class="language-neut">?t

↓

either(unit, t)
</code></pre>
<h3 id="type-43"><a class="header" href="#type-43">Type</a></h3>
<p>Derived from the syntax sugar.</p>
<h2 id="e1--en"><a class="header" href="#e1--en"><code>[e1, ..., en]</code></a></h2>
<p>You can use <code>[e1, ..., en]</code> to construct a list.</p>
<h3 id="example-47"><a class="header" href="#example-47">Example</a></h3>
<pre><code class="language-neut">define make-int-list(): list(int) {
  [1, 2, 3, 4, 5]
}
</code></pre>
<h3 id="syntax-47"><a class="header" href="#syntax-47">Syntax</a></h3>
<pre><code class="language-neut">[e1, ..., en] // n &gt;= 0
</code></pre>
<h3 id="semantics-45"><a class="header" href="#semantics-45">Semantics</a></h3>
<p><code>[e1, ..., en]</code> is the following syntax sugar:</p>
<pre><code class="language-neut">[e1, ..., en]

↓

Cons(e1, Cons(..., Cons(en, Nil)...))
</code></pre>
<h3 id="type-44"><a class="header" href="#type-44">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="with--bind"><a class="header" href="#with--bind"><code>with</code> / <code>bind</code></a></h2>
<p>You can use <code>with</code> / <code>bind</code> as &quot;do-notations&quot; in other languages.</p>
<h3 id="example-48"><a class="header" href="#example-48">Example</a></h3>
<pre><code class="language-neut">// define a monadic bind
define either-bind&lt;e, a, b&gt;(x: either(e, a), k: (a) -&gt; either(e, b)): either(e, b) {
  match x {
  | Left(err) =&gt;
    Left(err)
  | Right(value) =&gt;
    k(value)
  }
}

define test(): either(&amp;text, int) {
  // ... and supply it to `with`
  with either-bind {
    bind _: bool = Left(&quot;hello&quot;) in
    bind _: bool = Left(&quot;hello&quot;) in
    bind _ = Right(True) in
    bind _: bool =
      bind _ = Right(True) in
      Left(&quot;hello&quot;)
    in
    bind _: bool = Left(&quot;hello&quot;) in
    bind _: type = Right(int) in
    Right(10)
  }
}
</code></pre>
<h3 id="syntax-48"><a class="header" href="#syntax-48">Syntax</a></h3>
<pre><code class="language-neut">with f {
  e
}

bind x = e1 in
e2

bind x: t = e1 in
e2
</code></pre>
<h3 id="semantics-46"><a class="header" href="#semantics-46">Semantics</a></h3>
<p><code>with</code> / <code>bind</code> is the syntax sugar defined by the following five translation rules:</p>
<pre><code class="language-neut">// (1) -----------------------------------------------------

with f {
  bind x = e1 in
  e2
}

↓

f(
  with f {e1},
  function (x) {
    with f {e2}
  }
)

// (2) -----------------------------------------------------

with f {
  LET x = e1 in // LET must be one of `let`, `try`, or `tie`
  e2
}

↓

LET x = with f {e1} in
with f {e2}


// (3) -----------------------------------------------------

with f {
  e1;
  e2
}

↓

with f {e1};
with f {e2}

// (4) -----------------------------------------------------

with f {
  use e {x1 ..., xn} in
  cont
}

↓

use e {x1, ..., xn} in
with f {cont}

// (5) -----------------------------------------------------

with f {e}

↓

e
</code></pre>
<p>The rule <code>(5)</code> is used only when all the other rules are unavailable.</p>
<h3 id="type-45"><a class="header" href="#type-45">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-29"><a class="header" href="#note-29">Note</a></h3>
<ul>
<li><code>with</code>/<code>bind</code> is the ordinary do-notation except that:
<ul>
<li>it must have an explicit monadic binder, and</li>
<li>it doesn't have monadic return.</li>
</ul>
</li>
</ul>
<h2 id="e-1"><a class="header" href="#e-1"><code>{e}</code></a></h2>
<p><code>{e}</code> can be used as parentheses in other languages.</p>
<pre><code class="language-neut">              // 🌟
define foo(f: {(int) -&gt; (bool)} -&gt; bool): bool {
  let g =
    function (x: int) {
      True
    }
  in
  f(g)
}


// cf.
define bar(f: (int) -&gt; (bool) -&gt; bool): bool {
  f(10)(True)
}
</code></pre>
<h3 id="syntax-49"><a class="header" href="#syntax-49">Syntax</a></h3>
<pre><code class="language-neut">{e}
</code></pre>
<h3 id="semantics-47"><a class="header" href="#semantics-47">Semantics</a></h3>
<p>The semantics of <code>{e}</code> is the same as <code>e</code>.</p>
<h3 id="type-46"><a class="header" href="#type-46">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: a
----------
Γ ⊢ {e}: a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives"><a class="header" href="#primitives">Primitives</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="primitives.html#primitive-types-and-functions">Primitive Types and Functions</a></li>
<li><a href="primitives.html#core-types-and-functions">Core Types and Functions</a></li>
</ul>
<h2 id="primitive-types-and-functions"><a class="header" href="#primitive-types-and-functions">Primitive Types and Functions</a></h2>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<p>Neut supports integers and floats. More specifically, the following types are supported:</p>
<ul>
<li>integer types: <code>intN (= int1, int2, int3, ..., int64)</code></li>
<li>float types: <code>floatN (= float16, float32, float64)</code></li>
</ul>
<p>You can also use <code>int</code> and <code>float</code>. These are just syntax sugar for <code>int64</code> and <code>float64</code>, respectively.</p>
<h3 id="primitive-functions"><a class="header" href="#primitive-functions">Primitive Functions</a></h3>
<p>These primitive types have a lot of primitive functions from LLVM:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>integers</th><th>floats</th></tr></thead><tbody>
<tr><td>arithmetics</td><td>add, sub, mul, div, rem, udiv, urem, or, xor, shl, lshr, ashr</td><td>neg, add, sub, mul, div, rem</td></tr>
<tr><td>comparison</td><td>eq, ne, gt, ge, lt, le, ugt, uge, ult, ule</td><td>eq, gt, ge, lt, le, ne, ord, ueq, ugt, uge, ult, ule, une, uno, false, true</td></tr>
</tbody></table>
</div>
<p>For example, <code>add-int32</code>, <code>neg-float64</code>, <code>eq-int64</code>, and <code>gt-float32</code> are available.</p>
<p>Neut uses LLVM's integer types and float types for its primitive types. Thus, the primitive integer types in Neut are signless. More specifically, the signedness of an integer type in Neut resides in functions, not values.</p>
<p>For example, <code>div-int64</code> interprets its two arguments as signed integers and returns its (signed) result. <code>udiv-int64</code> interprets its two arguments as unsigned integers and returns its (unsigned) result. Integer functions prefixed with <code>u</code> are for unsigned functions.</p>
<p>The internal representation of the integer types in Neut is the same as that of LLVM. Therefore, they are based on the two's complement representation. That is why Neut doesn't have something like <code>uadd-int64</code>. The <code>u</code>-prefixed integer functions are there only when we need different behaviors for different signednesses.</p>
<p>The following conversion functions are also available: <code>trunc</code>, <code>zext</code>, <code>sext</code>, <code>fptrunc</code>, <code>fpext</code>, <code>fptoui</code>, <code>fptosi</code>, <code>uitofp</code>, and <code>sitofp</code>.</p>
<p>For example, <code>trunc-int64-int32</code>, <code>zext-int8-int32</code>, <code>fptoui-float32-int64</code>, and <code>uitofp-int64-float64</code> are available.</p>
<p>For their detailed behaviors, please refer to <a href="https://llvm.org/docs/LangRef.html">the LLVM language reference</a>.</p>
<div class="info-block">
<p>Primitive functions for <code>int</code> and <code>float</code> are also available. For example, you can use <code>div-int</code>, <code>eq-int</code>, <code>add-float</code>, etc.</p>
</div>
<h2 id="core-types-and-functions"><a class="header" href="#core-types-and-functions">Core Types and Functions</a></h2>
<p>The <a href="./modules.html#preset">preset</a> of the core library (something like Prelude in other languages) is imported automatically and provides some types and functions. These types and functions can also be used as primitives. Things like the below are defined in the library:</p>
<pre><code class="language-neut">data void {}

data unit {
| Unit
}

data bool {
| False
| True
}

data list(a) {
| Nil
| Cons(a, list(a))
}

// you can also write `?a` instead of `either(unit, a)`
data either(a, b) {
| Left(a)
| Right(b)
}

data pair(a, b) {
| Pair(left: a, right: b)
}
</code></pre>
<p>Functions for those types are also defined in the library. For more, please see <a href="https://github.com/vekatze/neut-core/tree/main/source">the source of the core library</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basis"><a class="header" href="#basis">Basis</a></h1>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="./basis.html#on-executing-types">On Executing Types</a></li>
<li><a href="./basis.html#allocation-canceling">Allocation Canceling</a></li>
<li><a href="./basis.html#name-resolution">Name Resolution</a></li>
<li><a href="./basis.html#leading-bars-and-trailing-commas">Leading Bars and Trailing Commas</a></li>
<li><a href="./basis.html#compiler-configuration">Compiler Configuration</a></li>
<li><a href="./basis.html#other-basic-facts">Other Basic Facts</a></li>
</ul>
<h2 id="on-executing-types"><a class="header" href="#on-executing-types">On Executing Types</a></h2>
<p>A type in Neut is compiled into a pointer to a binary function like the below (pseudo-code):</p>
<pre><code class="language-neut">define discard-or-copy-value(action-selector, value) {
  if eq-int(action-selector, 0) {
    discard-value(value);
    Unit
  } else {
    let new-value = copy-value(value) in
    new-value
  }
}
</code></pre>
<p>These functions are then used to discard/copy values when necessary.</p>
<h3 id="discarding-values"><a class="header" href="#discarding-values">Discarding Values</a></h3>
<p>Let's see how types are executed when discarding values. For example, consider the following code:</p>
<pre><code class="language-neut">define foo(xs: list(int)): unit {
  Unit
}
</code></pre>
<p>Note that the variable <code>xs</code> isn't used. Because of that, the compiler translates the code above into the below (pseudo-code; won't typecheck):</p>
<pre><code class="language-neut">define foo(xs: list(int)): unit {
  let f = list(int) in
  f(0, xs); // passing `0` to discard `xs`
  Unit
}
</code></pre>
<p>Note that the above example executes the type <code>list(int)</code> as a function.</p>
<h3 id="copying-values"><a class="header" href="#copying-values">Copying Values</a></h3>
<p>Let's see how types are executed when copying values. For example, consider the following code:</p>
<pre><code class="language-neut">define foo(!xs: list(int)): unit {
  some-func(!xs, !xs)
}
</code></pre>
<p>Note that the variable <code>!xs</code> is used twice. Because of that, the compiler translates the above code into the below (pseudo-code; won't typecheck):</p>
<pre><code class="language-neut">define foo(!xs: list(int)): unit {
  let f = list(int) in
  let xs-clone = f(1, !xs) in // passing `1` to copy `xs`
  some-func(xs-clone, !xs)
}
</code></pre>
<p>Note that the above example executes the type <code>list(int)</code> as a function.</p>
<p>You must prefix a variable with <code>!</code> if the variable needs to be copied. You must also prefix free variables in a term-level <code>define</code> with <code>!</code> if they cannot be copied for free.</p>
<p>The prefix <code>!</code> is unnecessary if the variable can be copied for free.</p>
<h3 id="on-immediate-values"><a class="header" href="#on-immediate-values">On Immediate Values</a></h3>
<p>We don't have to discard immediates like integers or floats because their internal representations don't depend on memory-related operations like <code>malloc</code> or <code>free</code>. Because of that, &quot;discarding&quot; immediate values does nothing. Also, &quot;copying&quot; immediate values means reusing original values.</p>
<p>More specifically, the type of an immediate is compiled into a pointer to the following function (pseudo-code):</p>
<pre><code class="language-neut">inline discard-or-copy-immediate(selector, value) {
  if eq-int(selector, 0) {
    0     // discard: we have nothing to do on `value`
  } else {
    value // copy: we can simply reuse the immediate `value`
  }
}
</code></pre>
<p>These fake discarding/copying are optimized away at compile-time.</p>
<p>Also, this function is internally called <code>&quot;base.#.imm&quot;</code>. Try compiling your project as follows:</p>
<pre><code class="language-sh">neut build TARGET --emit llvm --skip-link
</code></pre>
<p>Then, take a peek at the <code>build</code> directory. You'll find the name here and there.</p>
<div class="info-block">
<p>Since every type is translated into a pointer to a function, a type is an immediate value. Thus, <code>type</code> is compiled into <code>base.#.imm</code>.</p>
</div>
<h2 id="allocation-canceling-1"><a class="header" href="#allocation-canceling-1">Allocation Canceling</a></h2>
<p>Thanks to its static nature, memory allocation in Neut can sometimes be optimized away. Consider the following code:</p>
<pre><code class="language-neut">data int-list {
| Nil
| Cons(int, int-list)
}

// [1, 5, 9] =&gt; [2, 6, 10]
define increment(xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    Nil
  // ↓ the `Cons` clause
  | Cons(x, rest) =&gt;
    Cons(add-int(x, 1), increment(rest))
  }
}
</code></pre>
<p>The expected behavior of the <code>Cons</code> clause above would be something like the following:</p>
<ol>
<li>obtain <code>x</code> and <code>rest</code> from <code>xs</code></li>
<li><code>free</code> the outer tuple of <code>xs</code></li>
<li>calculate <code>add-int(x, 1)</code> and <code>increment(rest)</code></li>
<li>allocate memory region using <code>malloc</code> to return the result</li>
<li>store the calculated values to the pointer and return it</li>
</ol>
<p>However, since the size of <code>Cons(x, rest)</code> and <code>Cons(add-int(x, 1), increment(rest))</code> are known to be the same at compile-time, the pair of <code>free</code> and <code>malloc</code> should be able to be optimized away, as follows:</p>
<ol>
<li>obtain <code>x</code> and <code>rest</code> from <code>xs</code></li>
<li>calculate <code>add-int(x, 1)</code> and <code>increment(rest)</code></li>
<li>store the calculated values to <code>xs</code> (overwrite)</li>
</ol>
<p>And Neut does this optimization. When a <code>free</code> is required, Neut looks for a <code>malloc</code> that is the same size and optimizes away such a pair if one exists. The resulting assembly code thus performs in-place updates.</p>
<h3 id="allocation-canceling-and-branching"><a class="header" href="#allocation-canceling-and-branching">Allocation Canceling and Branching</a></h3>
<p>This optimization &quot;penetrates&quot; branching. For example, consider the following:</p>
<pre><code class="language-neut">// (an `insert` function in bubble sort)
define insert(v: int, xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    // ...
  | Cons(y, ys) =&gt;           // (X)
    if gt-int(v, y) {
      Cons(y, insert(v, ys)) // (Y)
    } else {
      Cons(v, Cons(y, ys))   // (Z)
    }
  }
}
</code></pre>
<p>At point <code>(X)</code>, <code>free</code> against <code>xs</code> is required. However, this <code>free</code> can be canceled since <code>malloc</code>s of the same size can be found in all the possible branches (here, <code>(Y)</code> and <code>(Z)</code>). Thus, in the code above, the deallocation of <code>xs</code> at <code>(X)</code> is removed, and the memory region of <code>xs</code> is reused at <code>(Y)</code> and <code>(Z)</code>, resulting in an in-place update of <code>xs</code>.</p>
<p>On the other hand, consider rewriting the code above into something like the following:</p>
<pre><code class="language-neut">define foo(v: int, xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    // ...
  | Cons(y, ys) =&gt;         // (X')
    if gt-int(v, y) {
      Nil                  // (Y')
    } else {
      Cons(v, Cons(y, ys)) // (Z')
    }
  }
}
</code></pre>
<p>At this time, the <code>free</code> against <code>xs</code> at <code>(X')</code> can't be optimized away since there exists a branch (namely, <code>(Y')</code>) that doesn't perform <code>malloc</code> that is of the same size as <code>xs</code>.</p>
<h3 id="how-effective-is-this-optimization-1"><a class="header" href="#how-effective-is-this-optimization-1">How Effective Is This Optimization?</a></h3>
<p>Please see <a href="./static-memory-management.html#how-effective-is-this-optimization">here</a>.</p>
<h2 id="name-resolution"><a class="header" href="#name-resolution">Name Resolution</a></h2>
<h3 id="resolving-module-aliases"><a class="header" href="#resolving-module-aliases">Resolving Module Aliases</a></h3>
<p>Let's see how the name of a module alias is resolved. Here, the name of a module alias is something like the <code>core</code> in <code>core.text.io.get-line</code>:</p>
<pre><code class="language-neut">import {
  core.text.io,
}

define use-external-module-function(): text {
           // 🌟
  let value = core.text.io.get-line() in
  ...
}
</code></pre>
<p>When compiling a module, the compiler reads the field <code>dependency</code> in the <code>module.ens</code> and adds correspondences like the below to its internal state:</p>
<pre><code class="language-neut">// alias =&gt; (the digest of the library)
core =&gt; &quot;jIx5FxfoymZ-X0jLXGcALSwK4J7NlR1yCdXqH2ij67o&quot;
foo-module =&gt; &quot;JEpjuzZ0rlqxiVuCnD000jEKIA_Y6ku1L3J139h3M6Q&quot;
bar-module =&gt; &quot;zptXghmyD5druBl8kx2Qrei6O6fDsKCA7z2KoHp1aqA&quot;
...
</code></pre>
<p>The compiler then resolves aliases like below:</p>
<pre><code class="language-text">core.text.io.get-line

↓

jIx5FxfoymZ-X0jLXGcALSwK4J7NlR1yCdXqH2ij67o=.text.io.get-line

--------------

foo-module.path.to.some.file.my-function

↓

JEpjuzZ0rlqxiVuCnD000jEKIA_Y6ku1L3J139h3M6Q.path.to.some.file.my-function

--------------

...
</code></pre>
<h3 id="resolving-this"><a class="header" href="#resolving-this">Resolving <code>this</code></a></h3>
<p>Let's see how <code>this</code> is resolved. Here, <code>this</code> is a component of a global variables, like the below:</p>
<pre><code class="language-neut">import {
  this.path.to.file,
}

define use-my-function(): text {
           // 🌟
  let value = this.path.to.file.my-function() in
  ...
}
</code></pre>
<p>The first thing to note here is that every module is marked as &quot;main&quot; or &quot;library&quot; when running compilation. The main module is the module in which <code>neut build</code> is executed. Library modules are all the other modules that are necessary for compilation.</p>
<p>All the occurrences of <code>this</code> in the main module are kept intact during compilation. Thus, the resulting assembly file contains symbols like <code>this.foo.bar</code>.</p>
<p>On the other hand, all the occurrences of <code>this</code> in a library module are resolved into their corresponding digests. More specifically, when processing a library module, the compiler adds correspondences like the below:</p>
<pre><code class="language-neut">// this =&gt; (the digest of the library)
this =&gt; &quot;jIx5FxfoymZ-X0jLXGcALSwK4J7NlR1yCdXqH2ij67o&quot;
</code></pre>
<p>The compiler then resolves <code>this</code> like below:</p>
<pre><code class="language-text">this.text.io.get-line

↓

jIx5FxfoymZ-X0jLXGcALSwK4J7NlR1yCdXqH2ij67o=.text.io.get-line
</code></pre>
<p>Thus, the resulting assembly file contains symbols like the above.</p>
<h2 id="trailing-commas-and-leading-bars"><a class="header" href="#trailing-commas-and-leading-bars">Trailing Commas and Leading Bars</a></h2>
<h3 id="comma-separated-sequences-and-sequences"><a class="header" href="#comma-separated-sequences-and-sequences">Comma-Separated Sequences (And-Sequences)</a></h3>
<p>Every comma-separated sequence like <code>a, b, c</code> can have a trailing comma like <code>a, b, c,</code>.</p>
<p>If a comma-separated sequence has a trailing comma, the sequence is formatted vertically by the built-in formatter.</p>
<h3 id="bar-separated-sequences-or-sequences"><a class="header" href="#bar-separated-sequences-or-sequences">Bar-Separated Sequences (Or-Sequences)</a></h3>
<p>Every bar-separated sequence like <code>a | b | c</code> can have a leading bar like <code>| a | b | c</code>.</p>
<p>If a bar-separated sequence has a leading bar, the sequence is formatted vertically by the built-in formatter.</p>
<h2 id="compiler-configuration"><a class="header" href="#compiler-configuration">Compiler Configuration</a></h2>
<p>The behavior of the compiler can be adjusted using the following environment variables:</p>
<div class="table-wrapper"><table><thead><tr><th>Environment Variable</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>NEUT_CLANG</code></td><td>the command to call <code>clang</code></td></tr>
<tr><td><code>NEUT_CORE_MODULE_DIGEST</code></td><td>the digest of the core module</td></tr>
<tr><td><code>NEUT_CORE_MODULE_URL</code></td><td>the URL of the core module</td></tr>
</tbody></table>
</div>
<p>The default values are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Environment Variable</th><th>Default Value</th></tr></thead><tbody>
<tr><td><code>NEUT_CLANG</code></td><td><code>clang</code></td></tr>
<tr><td><code>NEUT_CORE_MODULE_DIGEST</code></td><td>(undefined; you must set one)</td></tr>
<tr><td><code>NEUT_CORE_MODULE_URL</code></td><td>(undefined; you must set one)</td></tr>
</tbody></table>
</div>
<h2 id="other-basic-facts"><a class="header" href="#other-basic-facts">Other Basic Facts</a></h2>
<ul>
<li>Neut is call-by-value</li>
<li>Neut is impure</li>
<li>The type of <code>main</code> must be <code>() -&gt; unit</code></li>
<li>A module named <code>core</code> is treated specially (treated as the &quot;prelude&quot; library)
<ul>
<li>Syntactic constructs like <code>[1, 2, 3]</code> depends on functions in <code>core</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-next"><a class="header" href="#what-is-next">What is Next?</a></h1>
<p>You can improve this book, this language, or this world by:</p>
<ul>
<li>Writing libraries or executables</li>
<li>Opening PRs to fix typos, grammatical errors, or whatever in this book</li>
<li>Finding bugs and reporting them on GitHub, hopefully with PRs</li>
<li>Sharing the language on SNS</li>
<li>Starring the <a href="https://github.com/vekatze/neut">repository</a></li>
<li>...</li>
</ul>
<h2 id="introducing-some-libraries"><a class="header" href="#introducing-some-libraries">Introducing Some Libraries</a></h2>
<p>I've been enjoying this language by myself and have written several libraries:</p>
<ul>
<li><a href="https://github.com/vekatze/ansi-terminal">ansi-terminal</a> - A thin layer over ANSI escape sequences</li>
<li><a href="https://github.com/vekatze/argot">argot</a> - A monadic CLI argment parser</li>
<li><a href="https://github.com/vekatze/ars-postgres">ars-postgres</a> - A PostgreSQL client over libpq</li>
<li><a href="https://github.com/vekatze/binary-builder">binary-builder</a> - Constructs binary data efficiently</li>
<li><a href="https://github.com/vekatze/dotenv-nt">dotenv</a> - Locates and loads env files</li>
<li><a href="https://github.com/vekatze/http-base-nt">http-base</a> - Provides basic HTTP entities</li>
<li><a href="https://github.com/vekatze/json-nt">json</a> - Handles JSON values</li>
<li><a href="https://github.com/vekatze/marshal">marshal</a> - Saves and loads values using files</li>
<li><a href="https://github.com/vekatze/noa">noa</a> - A test kit emphasizing the property-based approach</li>
<li><a href="https://github.com/vekatze/path-nt">path</a> - Provides path-related operations</li>
<li><a href="https://github.com/vekatze/rin">rin</a> - An HTTP client over libcurl</li>
<li><a href="https://github.com/vekatze/socket-nt">socket</a> - A thin layer over network sockets</li>
<li><a href="https://github.com/vekatze/sui">sui</a> - An HTTP server</li>
<li><a href="https://github.com/vekatze/text-builder">text-builder</a> - Constructs texts efficiently</li>
<li><a href="https://github.com/vekatze/time-nt">time</a> - Provides time-related operations</li>
<li><a href="https://github.com/vekatze/zonk">zonk</a> - A parser combinator</li>
</ul>
<p>Hope you'll enjoy this too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-installation"><a class="header" href="#manual-installation">Manual Installation</a></h1>
<p>Make sure all the following dependencies are on your system:</p>
<ul>
<li><code>clang (&gt;= 15.0.0)</code></li>
<li><code>curl</code></li>
<li><code>tar</code></li>
<li><code>zstd</code></li>
</ul>
<p>Add the below to your <code>.bashrc</code>, <code>.zshrc</code>, etc.</p>
<pre><code class="language-sh"># this sets the core module (or &quot;prelude&quot;) that is used in `neut create`
export NEUT_CORE_MODULE_URL=&quot;https://github.com/vekatze/neut-core/raw/main/archive/0-50-44.tar.zst&quot;
export NEUT_CORE_MODULE_DIGEST=&quot;BSFWNZEaZKuKbRIvpyNuQb79hZVQw4iFRm9tOJNHJpw&quot;
</code></pre>
<p>Then, get the compiler:</p>
<pre><code class="language-sh"># macOS (arm64)
curl -L -o ~/.local/bin/neut https://github.com/vekatze/neut/releases/latest/download/neut-arm64-darwin
# Linux (amd64)
curl -L -o ~/.local/bin/neut https://github.com/vekatze/neut/releases/latest/download/neut-amd64-linux
# Linux (arm64)
curl -L -o ~/.local/bin/neut https://github.com/vekatze/neut/releases/latest/download/neut-arm64-linux

# make it executable
chmod +x ~/.local/bin/neut
</code></pre>
<p>Ensure that <code>~/.local/bin</code> is in your <code>$PATH</code>.</p>
<div class="info-block">
<p>You can put the binary anywhere you want as long as the location is in your <code>$PATH</code>.</p>
</div>
<p>You can check if the compiler is installed correctly by running <code>neut version</code>:</p>
<pre><code class="language-sh">neut version
#=&gt; X.Y.Z
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h1>
<p>This chapter provides some tools for writing programs in Neut.</p>
<p><a href="./lovely-lsp-showcase.html">Lovely LSP Showcase</a> shows what the LSP server is like using GIF animations.</p>
<p><a href="./rapid-prototyping.html">Rapid Prototyping</a> shows how the subcommand <code>neut zen</code> works in harmony with editors.</p>
<p><a href="./editor-setup.html">Editor Setup</a> explains how to set up editors like Emacs, Neovim, Vim, or Visual Studio Code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lovely-lsp-showcase"><a class="header" href="#lovely-lsp-showcase">Lovely LSP Showcase</a></h1>
<p>The compiler contains an LSP server. Let's see what it is like.</p>
<h2 id="showcase"><a class="header" href="#showcase">Showcase</a></h2>
<p>The LSP server currently has the following features:</p>
<ul>
<li><a href="lovely-lsp-showcase.html#lint">Lint</a></li>
<li><a href="lovely-lsp-showcase.html#completion--automatic-import">Completion (+ automatic import)</a></li>
<li><a href="lovely-lsp-showcase.html#jump-to-definition">Jump to Definition</a></li>
<li><a href="lovely-lsp-showcase.html#find-references">Find References</a></li>
<li><a href="lovely-lsp-showcase.html#format-on-save">Format on Save</a></li>
<li><a href="lovely-lsp-showcase.html#remove-unused-imports">Remove Unused Imports</a></li>
<li><a href="lovely-lsp-showcase.html#show-the-type-of-a-variable">Show the Type of a Variable</a></li>
<li><a href="lovely-lsp-showcase.html#highlight-symbols">Highlight Symbols</a></li>
</ul>
<h3 id="lint"><a class="header" href="#lint">Lint</a></h3>
<p><img src="./image/screencasts/lint.gif" alt="lint" title="lint" /></p>
<h3 id="completion--automatic-import"><a class="header" href="#completion--automatic-import">Completion (+ automatic import)</a></h3>
<p><img src="./image/screencasts/completion.gif" alt="completion" title="completion" /></p>
<h3 id="jump-to-definition"><a class="header" href="#jump-to-definition">Jump to Definition</a></h3>
<p><img src="./image/screencasts/jump-to-definition.gif" alt="jump to definition" title="jump to definition" /></p>
<h3 id="find-references"><a class="header" href="#find-references">Find References</a></h3>
<p><img src="./image/screencasts/find-references.gif" alt="find references" title="find references" /></p>
<h3 id="format-on-save"><a class="header" href="#format-on-save">Format on Save</a></h3>
<p><img src="./image/screencasts/format-on-save.gif" alt="format on save" title="format on save" /></p>
<h3 id="remove-unused-imports"><a class="header" href="#remove-unused-imports">Remove Unused Imports</a></h3>
<p><img src="./image/screencasts/minimize.gif" alt="remove unused imports" title="remove unused imports" /></p>
<h3 id="show-the-type-of-a-variable"><a class="header" href="#show-the-type-of-a-variable">Show the Type of a Variable</a></h3>
<p><img src="./image/screencasts/hover-type.gif" alt="hover type" title="show the type of a variable" /></p>
<h3 id="highlight-symbols"><a class="header" href="#highlight-symbols">Highlight Symbols</a></h3>
<p><img src="./image/screencasts/highlight.gif" alt="highlight" title="highlight symbols" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rapid-prototyping"><a class="header" href="#rapid-prototyping">Rapid Prototyping</a></h1>
<p>You can use <a href="./commands.html#neut-zen">the subcommand</a> <code>neut zen</code> to sketch a function.</p>
<p>Below is an example in which Emacs runs <code>neut zen path/to/file.nt</code> when <code>C-c C-c</code> is typed:</p>
<p><img src="./image/screencasts/zen.gif" alt="zen" title="zen" /></p>
<p>This feels a bit like a scripting language, doesn't it?</p>
<h3 id="notes-for-emacs"><a class="header" href="#notes-for-emacs">Notes for Emacs</a></h3>
<p>The configuration for Emacs in the above example is like the one below:</p>
<pre><code class="language-text">(defun ext/neut-compile ()
  (interactive)
  (compile (concat &quot;neut zen &quot; (buffer-file-name))))

(bind-key &quot;C-c C-c&quot; 'ext/neut-compile 'neut-mode-map)
</code></pre>
<p>The above example also uses the package <code>fancy-compilation</code>:</p>
<pre><code class="language-text">(use-package fancy-compilation
  :init
  (fancy-compilation-mode t)
  (setq compilation-error-regexp-alist nil)
  (setq compilation-highlight-regexp nil)
  (setq compilation-mode-font-lock-keywords nil)
  (setq fancy-compilation-quiet-prelude t))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-setup"><a class="header" href="#editor-setup">Editor Setup</a></h1>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p><a href="https://github.com/vekatze/neut-mode">https://github.com/vekatze/neut-mode</a></p>
<p><code>neut-mode</code> is an Emacs major mode for Neut. The mode provides syntax highlighting and automatic indentation. It also provides a way to use the LSP server via <code>lsp-mode</code> and <code>eglot</code>.</p>
<p><code>neut-mode</code> is available on <a href="https://melpa.org/#/neut-mode">Melpa</a>. You can install the package by:</p>
<pre><code class="language-text">M-x package-install RET neut-mode RET
</code></pre>
<p>Below is an example configuration:</p>
<pre><code class="language-lisp">(use-package neut-mode
  :init
  (defun my/neut-initialize ()
    (interactive)
    (when (featurep 'lsp-mode)
      (setq-local lsp-before-save-edits t)
      (lsp)))
  (defun my/neut-compile ()
    (interactive)
    (compile (concat &quot;neut zen &quot; (buffer-file-name))))
  (add-hook 'neut-mode-hook 'my/neut-initialize)
  :bind
  (:map neut-mode-map
        (&quot;C-c C-c&quot; . 'my/neut-compile)))
</code></pre>
<h2 id="neovim"><a class="header" href="#neovim">Neovim</a></h2>
<p><a href="https://github.com/vekatze/vim-neut">https://github.com/vekatze/vim-neut</a></p>
<p>You can install <code>vim-neut</code> for syntax highlighting and automatic indentation.</p>
<p>The installation process is as usual. Just use your favorite plugin manager like <a href="https://github.com/folke/lazy.nvim">lazy.nvim</a>.</p>
<p>If you want to use the built-in LSP client, for example, you can do something like the following:</p>
<pre><code class="language-vim">vim.api.nvim_create_autocmd(&quot;FileType&quot;, {
  desc = &quot;Launch Neut's LSP server&quot;,
  pattern = &quot;neut&quot;,
  callback = function()
    vim.lsp.start({
      name = &quot;neut lsp&quot;,
      cmd = { &quot;neut&quot;, &quot;lsp&quot; },
      root_dir = vim.fs.dirname(vim.fs.find({ &quot;module.ens&quot; }, { upward = true })[1]),
    })
  end
})
</code></pre>
<p>The points are as follows:</p>
<ul>
<li>Run <code>neut lsp</code> to start the LSP server</li>
<li>Look for <code>module.ens</code> to find the root of a module</li>
</ul>
<p>You should be able to use any other LSP clients for Neovim.</p>
<h2 id="vim"><a class="header" href="#vim">Vim</a></h2>
<p><a href="https://github.com/vekatze/vim-neut">https://github.com/vekatze/vim-neut</a></p>
<p>You can install <code>vim-neut</code> for syntax highlighting and automatic indentation.</p>
<p>The installation process is as usual. Just use your favorite plugin manager like <a href="https://github.com/junegunn/vim-plug">vim-plug</a>.</p>
<p>If you want to use <a href="https://github.com/prabirshrestha/vim-lsp">vim-lsp</a>, for example, you can do something like the following:</p>
<pre><code class="language-vim">call plug#begin()

&quot; ...

Plug 'vekatze/vim-neut'

Plug 'prabirshrestha/vim-lsp'

&quot; ...

call plug#end()

if executable('neut')
    au User lsp_setup call lsp#register_server({
        \ 'name': 'neut',
        \ 'cmd': {server_info-&gt;['neut', 'lsp']},
        \ 'allowlist': ['neut'],
        \ })
endif


function! s:on_lsp_buffer_enabled() abort
    &quot; ... (see the readme of vim-lsp)
endfunction


augroup lsp_install
    &quot; ... (see the readme of vim-lsp)
augroup END
</code></pre>
<p>The points are as follows:</p>
<ul>
<li>Run <code>neut lsp</code> to start the LSP server</li>
<li>Look for <code>module.ens</code> to find the root of a module</li>
</ul>
<p>You should be able to use any other LSP clients for Vim.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p><a href="https://github.com/vekatze/vscode-neut">https://github.com/vekatze/vscode-neut</a></p>
<p>You can install <code>vscode-neut</code> for syntax highlighting, automatic indentation, and LSP support. This extension is available on the <a href="https://marketplace.visualstudio.com/items?itemName=vekatze.vscode-neut">Visual Studio Marketplace</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-execute-types"><a class="header" href="#how-to-execute-types">How to Execute Types</a></h1>
<h2 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of Contents</a></h2>
<ul>
<li><a href="how-to-execute-types.html#types-as-closed-functions">Types as Closed Functions</a></li>
<li><a href="how-to-execute-types.html#example-behavior-of-types">Example Behavior of Types</a></li>
<li><a href="how-to-execute-types.html#immediate-types">Immediate Types</a></li>
<li><a href="how-to-execute-types.html#polymorphic-types">Polymorphic Types</a></li>
<li><a href="how-to-execute-types.html#algebraic-data-types">Algebraic Data Types</a></li>
<li><a href="how-to-execute-types.html#advanced-function-types">Advanced: Function Types</a></li>
</ul>
<h2 id="types-as-closed-functions"><a class="header" href="#types-as-closed-functions">Types as Closed Functions</a></h2>
<p>Here, we'll see how a type is translated into a function that discards/copies the terms of the type. To see the basic idea, let's take a simple ADT for example:</p>
<pre><code class="language-neut">data item {
| New(int, int)
}
</code></pre>
<p>The internal representation of <code>New(10, 20)</code> is something like the below:</p>
<pre><code class="language-neut">New(10, 20)

// ↓ (compile)

let v = malloc({2-words}) in
store(10, v[0]);
store(20, v[1]);
v
</code></pre>
<h3 id="discardingcopying-a-value"><a class="header" href="#discardingcopying-a-value">Discarding/Copying a Value</a></h3>
<p>Now, let's see how to discard and copy the values of the type <code>item</code>.</p>
<p>A value <code>v</code> of type <code>item</code> can be discarded as follows:</p>
<pre><code class="language-neut">free(v)
</code></pre>
<p>The <code>v</code> can be copied as follows:</p>
<pre><code class="language-neut">// copy `v`, keeping the original `v` intact
let ptr = malloc({2-words}) in
store(ptr[0], v[0]); // ptr[0] := v[0]
store(ptr[1], v[1]); // ptr[1] := v[1]
ptr
</code></pre>
<p>Not a big deal, right?</p>
<h3 id="combining-discardingcopying-functions"><a class="header" href="#combining-discardingcopying-functions">Combining Discarding/Copying Functions</a></h3>
<p>Using the two procedures above, we can construct a closed function that discards and copies the values of the type <code>item</code>:</p>
<pre><code class="language-neut">define exp-item(selector, v) {
  if selector == 0 {
    // discard
    free(v)
  } else {
    // copy `v`
    let ptr = malloc({2-words}) in
    store(ptr[0], v[0]);
    store(ptr[1], v[1]);
    ptr
  }
}
</code></pre>
<p><code>exp-item(selector, v)</code> discards <code>v</code> if <code>selector</code> is 0. Otherwise, this function creates a copy of <code>v</code> and then returns it, keeping the original <code>v</code> intact.</p>
<p>The type <code>item</code> is compiled into a pointer to this function.</p>
<p>More generally, a type <code>a</code> is translated into a pointer to a closed function like below:</p>
<pre><code class="language-neut">define exp-a(selector, v) {
  if selector == 0 {
    // a proceduce that discards `v`
  } else {
    // a procedure that copies `v` (keeping the original `v` intact)
  }
}
</code></pre>
<p>We'll call such a closed function a resource exponential of <code>a</code>.</p>
<h2 id="example-behavior-of-types"><a class="header" href="#example-behavior-of-types">Example Behavior of Types</a></h2>
<p>This <code>exp-item</code> is called when a variable isn't used:</p>
<pre><code class="language-neut">let x = New(10, 20) in
print(&quot;hello&quot;) // `x` isn't used

// ↓ (compile)

let x = New(10, 20) in
let _ = exp-item(0, x) in // discard `x` by passing 0 as `selector`
print(&quot;hello&quot;)
</code></pre>
<p>This <code>exp-item</code> is also called when a variable is used more than twice:</p>
<pre><code class="language-neut">let x = New(10, 20) in
let a = foo(x) in // first use of `x`
let b = bar(x) in // second use of `x`
cont(a, b)

// ↓ (compile)

let x = New(10, 20) in
let x-copy = exp-item(1, x) in // copy `x` by passing 1 as `selector`
let a = foo(x-copy) in
let b = bar(x) in
cont(a, b)
</code></pre>
<div class="info-block">
<p>This discarding/copying procedure happens <em>immediately after a variable is defined</em>.</p>
</div>
<h2 id="immediate-types"><a class="header" href="#immediate-types">Immediate Types</a></h2>
<p>Immediates like integers or floats don't have to be discarded or copied since they don't rely on memory-related operations like <code>malloc</code> or <code>free</code>. This fact is reflected in the resulting function that <code>int</code> or <code>float</code> are translated into:</p>
<pre><code class="language-neut">define base.#.imm(selector, value) {
  if selector == 0 {
    0 // &quot;discarding&quot; doesn't have to do anything
  } else {
    value // &quot;copying&quot; simply reuses the original value
  }
}
</code></pre>
<p>Immediate types are compiled into this function. Noema types like <code>&amp;list(int)</code> are also translated into this function.</p>
<p>Uses of <code>base.#.imm</code> like <code>base.#.imm(1, some-value)</code> are optimized away by inlining.</p>
<div class="info-block">
<p>A type is compiled into a pointer to a closed function. This means that types are immediate values. Because of that, the type of types (<code>type</code>) is also compiled into <code>base.#.imm</code>.</p>
</div>
<h2 id="polymorphic-types"><a class="header" href="#polymorphic-types">Polymorphic Types</a></h2>
<p>Let's see how polymorphic values are copied. Consider the following code:</p>
<pre><code class="language-neut">define foo(a: type, x: a): pair(a, a) {
  Pair(x, x)
}
</code></pre>
<p>The code uses the variable <code>x</code> twice. Thus, this <code>x</code> must be copied according to the type <code>a</code>.</p>
<p>This can be done because the internal representation of <code>a</code> is a function that can discard and copy the values of type <code>a</code>. Thus, the above code is compiled into something like the below:</p>
<pre><code class="language-neut">define foo(a: type, x: a): pair(a, a) {
  let x-clone = a(1, x) in
  Pair(x, x-clone)
}
</code></pre>
<p>Thus, we can discard and copy values of polymorphic types.</p>
<h2 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h2>
<p>ADTs like the below also have resource exponentials, of course:</p>
<pre><code class="language-neut">data list(a) {
| Nil
| Cons(a, list(a))
}
</code></pre>
<p>The first thing to note is that the values of an ADT must be able to be discarded/copied using a closed function (since all the types in Neut are compiled into closed functions). This means the information about <code>a</code> in <code>list(a)</code> must be contained in the values.</p>
<p>That is, for example, the internal representation of <code>Nil</code> is something like below:</p>
<pre><code class="language-neut">(a, 0)
</code></pre>
<p>Here, the <code>0</code> is the discriminant for <code>Nil</code>. Also, that of <code>Cons(10, xs)</code> is:</p>
<pre><code class="language-neut">(a, 1, 10, xs)
</code></pre>
<p>Here, the <code>1</code> is the discriminant for <code>Cons</code>.</p>
<p>With that in mind, the resource exponential of <code>list(a)</code> will be something like the below (A bit lengthy; Skip it and just read the succeeding note if you aren't that interested in details):</p>
<pre><code class="language-neut">define exp-list(selector, v) {
  if selector == 0 {
    let d = get-discriminant(v) in
    if d == 0 {
      // discard Nil
      free(v)
    } else {
      // discard Cons
      let a = v[0] in
      let cons-head = v[1] in
      let cons-tail = v[2] in
      free(v);
      let () = a(0, v[1]) in // ← discard the head of cons using v[0]
      exp-list(0, v[2])
    }
  } else {
    let d = get-discriminant(v) in
    if d == 0 {
      // copy Nil
      let ptr = malloc({2-words}) in
      let a = v[0] in
      store(a, ptr[0]);
      store(d, ptr[1]);
      ptr
    } else {
      // copy Cons
      let ptr = malloc({4-words}) in
      let a = v[0] in
      let cons-head-copy = a(1, v[2]) in // ← copy the head of cons using v[0]
      let cons-tail-copy = exp-list(1, v[3]) in
      store(a, ptr[0]);
      store(d, ptr[1]);
      store(cons-head-copy, ptr[2]);
      store(cons-tail-copy, ptr[3]);
      ptr
    }
  }
}
</code></pre>
<p>The point is that <em>the type information in a value is loaded at runtime and used to discard/copy values</em>. This utilization of types is the main point of first-class types in Neut.</p>
<p>The main part of this section is now over. What follows is for curious cats.</p>
<h2 id="advanced-function-types"><a class="header" href="#advanced-function-types">Advanced: Function Types</a></h2>
<p>We'll see how function types like <code>(int) -&gt; bool</code> are translated.</p>
<p>Suppose we have a function like the below:</p>
<pre><code class="language-neut">define foo(a: type): int {
  let x: int = 10 in
  let y = type in
  let f =
    function (z: a) {  // lambda function
      let foo = x in   // ← x is a free var of this lambda
      let bar = y in   // ← y is also a free var of this lambda
      let buz = z in
      bar
    }
  in
  0
}
</code></pre>
<p>Let's see how the <code>lambda</code> inside the function is compiled.</p>
<h3 id="extracting-a-closed-chain-from-a-lambda"><a class="header" href="#extracting-a-closed-chain-from-a-lambda">Extracting a Closed Chain From a Lambda</a></h3>
<p>First, the compiler collects all the free variables in the lambda. Here, the compiler also collects all the free variables in the types of the free variables. Thus, in this case, the compiler constructs a list like below:</p>
<pre><code class="language-neut">[a, x, y, z]
</code></pre>
<p>This list is &quot;closed&quot; in the following sense. Consider annotating all the variables in the list by their variables, like below:</p>
<pre><code class="language-neut">[a: type, x: int, y: type, z: a]
</code></pre>
<p>This list is closed in that the term</p>
<pre><code class="language-neut">function (a: type, x: int, y: type, z: a) {
  Unit
}
</code></pre>
<p>contains no free variables. We'll call a list like this a closed chain.</p>
<h3 id="closure-conversion"><a class="header" href="#closure-conversion">Closure Conversion</a></h3>
<p>We'll use this closed chain to compile a lambda. The internal representation of a closure for the lambda will be a 3-word tuple like the following:</p>
<pre><code class="language-text">(Σ (a: type, x: int, y: type). a , (a, x, y, z), LABEL-TO-FUNCTION-DEFINITION)
 -----------------------------   ------------
 the type of the environment     the closed chain (i.e. environment)
</code></pre>
<p>This is more or less the usual closure conversion, except that we now have the types of the free variables in the closure.</p>
<h3 id="discardingcopying-a-closure"><a class="header" href="#discardingcopying-a-closure">Discarding/Copying a Closure</a></h3>
<p>Knowing its internal representation, we can now discard/copy a closure. To copy a closure, we can do the following:</p>
<pre><code class="language-neut">// copy a closure `cls`

let env-type = cls[0] in // get the type of the environment
let env      = cls[1] in // get the pointer to the environment
let label    = cls[2] in // get the label to the function

let env-clone = env-type(1, env) in // copy the environment using the type of it

// allocate new memory region for our new closure
let new-ptr = malloc(mul-int(3, word-size)) in

// store cloned values
store(env-type, new-ptr[0]);  // remember that a type is an immediate
store(env-clone, new-ptr[1]);
store(label, new-ptr[2]);     // note that a label is an immediate

new-ptr // ... and return the new closure
</code></pre>
<p>Discarding a closure can also be done with the same idea: discard the environment using the type information in the closure.</p>
<h3 id="translating-a-function-type"><a class="header" href="#translating-a-function-type">Translating a Function Type</a></h3>
<p>This leads us to translate the function type as follows:</p>
<pre><code class="language-neut">(x1: A1, ..., xn: An) -&gt; B

// ↓

define base.#.cls(action-selector, cls) {
  if action-selector == 0 {
    // discard

    // discard the environment using the type of it
    let env-type = cls[0] in
    let env      = cls[1] in
    env-type(0, env);

    // discard the tuple of the closure
    free(cls)
  } else {
    // copy

    // get the original values
    let env-type = cls[0] in
    let env      = cls[1] in
    let label    = cls[2] in

    // copy the environment using the type of it
    let env-clone = env-type(1, env) in

    let new-ptr = malloc(mul-int(3, word-size)) in
    // copy the original values
    store(env-type, new-ptr[0]);
    store(env-clone, new-ptr[1]);
    store(label, new-ptr[2]);

    // ... and return the new closure
    new-ptr
  }
}
</code></pre>
<div class="info-block">
<p>Every function type is translated into this same <code>base.#.cls</code>, no matter its argument types and the result types.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h1>
<p>You can find the source files for the following benchmarks <a href="https://github.com/vekatze/neut/tree/main/bench/action">here</a>.</p>
<h2 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of Contents</a></h2>
<ul>
<li><a href="benchmarks.html#bubble-sort">Bubble Sort</a></li>
<li><a href="benchmarks.html#dictionary-create--lookup">Dictionary (Create &amp; Lookup)</a></li>
<li><a href="benchmarks.html#intmap-create--lookup">IntMap (Create &amp; Lookup)</a></li>
<li><a href="benchmarks.html#additional-notes">Additional Notes</a></li>
</ul>
<h2 id="bubble-sort"><a class="header" href="#bubble-sort">Bubble Sort</a></h2>
<p>This test creates a random list of length <code>N</code> and performs bubble-sort on the list.</p>
<h3 id="linux-amd64"><a class="header" href="#linux-amd64">Linux (AMD64)</a></h3>
<p><img src="./image/graph/amd64-linux/bubble.png" alt="bubble sort" title="bubble sort" /></p>
<h3 id="macos-arm64"><a class="header" href="#macos-arm64">macOS (ARM64)</a></h3>
<p><img src="./image/graph/arm64-darwin/bubble.png" alt="bubble sort" title="bubble sort" /></p>
<h2 id="dictionary-create--lookup"><a class="header" href="#dictionary-create--lookup">Dictionary (Create &amp; Lookup)</a></h2>
<p>This test creates a random dictionary of size <code>N</code> and performs random lookups from the dictionary for <code>N</code> times.</p>
<h3 id="linux-amd64-1"><a class="header" href="#linux-amd64-1">Linux (AMD64)</a></h3>
<p><img src="./image/graph/amd64-linux/dictionary.png" alt="dictionary" title="dictionary" /></p>
<h3 id="macos-arm64-1"><a class="header" href="#macos-arm64-1">macOS (ARM64)</a></h3>
<p><img src="./image/graph/arm64-darwin/dictionary.png" alt="dictionary" title="dictionary" /></p>
<h2 id="intmap-create--lookup"><a class="header" href="#intmap-create--lookup">IntMap (Create &amp; Lookup)</a></h2>
<p>This test creates a random intmap of size <code>N</code> and performs random lookups from the intmap for <code>N</code> times.</p>
<h3 id="linux-amd64-2"><a class="header" href="#linux-amd64-2">Linux (AMD64)</a></h3>
<p><img src="./image/graph/amd64-linux/intmap.png" alt="IntMap" title="IntMap" /></p>
<h3 id="macos-arm64-2"><a class="header" href="#macos-arm64-2">macOS (ARM64)</a></h3>
<p><img src="./image/graph/arm64-darwin/intmap.png" alt="IntMap" title="IntMap" /></p>
<hr />
<h2 id="additional-notes"><a class="header" href="#additional-notes">Additional Notes</a></h2>
<p>I used the following hardware in the above benchmarks:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Hardware</th></tr></thead><tbody>
<tr><td>Linux (AMD64)</td><td>HP OMEN 16 2023 (7840HS, 32 GB, Debian)</td></tr>
<tr><td>macOS (ARM64)</td><td>Apple MacBook Pro 14 (M1 Max, 32 GB)</td></tr>
</tbody></table>
</div>
<p>I used the following commands to run benchmarks and generate the graphs:</p>
<pre><code class="language-sh">just bench-linux amd64-linux # Linux (AMD64)
just bench-darwin arm64-darwin # macOS (ARM64)
</code></pre>
<p>You may want to read <a href="https://github.com/vekatze/neut/blob/main/build/Dockerfile">the Dockerfile in the repository</a> to get the list of additional dependencies for running benchmarks. The list includes npm, hyperfine, etc.</p>
<p>Please tell me (hopefully gently) if some of the results are unfair because of reasons I overlooked.</p>

            <footer id="footer-paginator">

              <div id="footer-spacer"></div>

            </footer>
          </article>
          <div id="footer-wrapper">
            <footer id="footer-nav">
              <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-external-world.html"><strong aria-hidden="true">3.1.</strong> Hello External World</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
            </footer>
          </div>
        </main>
      </div>


      <script src="highlight.js"></script>
      <script src="book.js"></script>
    </div>
  </body>
</html>
