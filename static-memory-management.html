<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Static Memory Management - Neut Programming Language</title>
    <meta name="description" content="A functional programming language with static memory management." />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="css/general.css" />
    <link rel="stylesheet" href="highlight.css" />
    <meta property="og:title" content="Static Memory Management - Neut Programming Language" />
    <meta property="og:description" content="A functional programming language with static memory management." />
    <meta property="og:url" content="https://vekatze.github.io/neut/static-memory-management.md" />
    <meta property="og:type" content="article" />
  </head>
  <body>
    <div id="body-container">
      <header id="menu-bar">
        <h1 class="menu-title">
          <a href="overview.html">
            Neut Programming Language
          </a>
        </h1>

        <div class="right-buttons">
            <a href="https://github.com/vekatze/neut" class="menubar-item">
              <span>GitHub</span>
            </a>
        </div>
      </header>
      <div id="content-box">
        <aside id="sidebar">
          <nav class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-external-world.html"><strong aria-hidden="true">3.1.</strong> Hello External World</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html" class="active"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
          </nav>
        </aside>

        <main id="content" tabindex="0">
          <article id="content-inner">
            <h1 id="static-memory-management"><a class="header" href="#static-memory-management">Static Memory Management</a></h1>
<p>Here, we'll see how to write performant programs in Neut.</p>
<h2 id="what-youll-learn-here"><a class="header" href="#what-youll-learn-here">What You'll Learn Here</a></h2>
<ul>
<li>How memory regions are handled in Neut</li>
<li>How to bypass copying resources</li>
<li>How Neut optimizes memory allocations/deallocations</li>
</ul>
<h2 id="linearity-and-memory"><a class="header" href="#linearity-and-memory">Linearity and Memory</a></h2>
<p>In Neut, the content of a variable is <em>copied</em> according to its type <em>if the variable is used more than once</em>. Consider the following code:</p>
<pre><code class="language-neut">// before compilation (pseudo code)
define foo(xs: list(int)): list(int) {
  let ys = xs in // use `xs` (1)
  let zs = xs in // use `xs` (2)
  some-func(ys);
  other-func(zs);
  xs // use `xs` (3)
}
</code></pre>
<p>In the above code, the variable <code>xs</code> is used three times. Because of that, the content of <code>xs</code> is copied twice:</p>
<pre><code class="language-neut">// after compilation (pseudo-code)
define foo(xs: list(int)): list(int) {
  let xs1 = COPY-VALUE(list(int), xs) in
  let xs2 = COPY-VALUE(list(int), xs) in
  let ys = xs1 in
  let zs = xs2 in
  some-func(ys);
  other-func(zs);
  xs
}
</code></pre>
<p>Also, the content of a variable is <em>discarded</em> <em>if the variable isn't used</em>. Consider the following code:</p>
<pre><code class="language-neut">// before compilation
define bar(xs: list(int)): unit {
  Unit
}
</code></pre>
<p>In the above code, since <code>xs</code> isn't used, the content of <code>xs</code> is discarded as follows:</p>
<pre><code class="language-neut">// after compilation (pseudo-code)
define bar(xs: list(int)): unit {
  let _ = DISCARD-VALUE(list(int), xs) in
  Unit
}
</code></pre>
<p>Technically speaking, these discarding/copying operations also happen when the variable is an immediate value like an integer:</p>
<pre><code class="language-neut">define buz(x: int): unit {
  Unit
}

↓


// pseudo-code
define bar(x: int): unit {
  let _ = DISCARD-VALUE(int, x) in
  Unit
}
</code></pre>
<p>In practice, however, discarding/copying operations on immediate values are optimized away.</p>
<p>In the literature, a use of a variable is called <em>linear</em> if the variable is used exactly once. Neut's compiler translates programs so that every non-linear use of variables becomes linear, ignoring arguments in discarding/copying functions.</p>
<p>If you're interested in how Neut achieves these discarding/copying operations, please see <a href="./how-to-execute-types.html">How to Execute Types</a>.</p>
<h3 id="to-be-conscious-of-cloning-values"><a class="header" href="#to-be-conscious-of-cloning-values">To Be Conscious of Cloning Values</a></h3>
<p>Suppose the content of a variable were to be copied simply by using it more than once. In that case, we might suffer from unintended cloning and encounter unexpected performance degradation.</p>
<p>The compiler thus requires us to prefix the name of a variable with <code>!</code> when the variable needs to be copied. Let's consider the following code:</p>
<pre><code class="language-neut">define make-pair(xs: list(int)): pair(list(int), list(int)) {
  Pair(xs, xs)
}
</code></pre>
<p>When checking this code, the compiler will report an error because the code uses the variable <code>xs</code> twice and the variable isn't prefixed with <code>!</code>.</p>
<p>You can satisfy the compiler by renaming <code>xs</code> into <code>!xs</code>:</p>
<pre><code class="language-neut">define make-pair(!xs: list(int)): pair(list(int), list(int)) {
  Pair(!xs, !xs)
}
</code></pre>
<h3 id="free-variables-in-a-local-recursion"><a class="header" href="#free-variables-in-a-local-recursion">Free Variables in a Local Recursion</a></h3>
<p>This <code>!</code> is also required when using a free variable in a term-level <code>define</code>:</p>
<pre><code class="language-neut">define multi-print(!message: text): unit {
  let f =
    define self(counter: int): unit {
      if ge-int(counter, 10) {
        Unit
      } else {
        // `!message` is a free variable of `self`
        printf(&quot;message: {}\n&quot;, [!message]);
        self(add-int(counter, 1))
      }
    }
  in
  f(0)
}
</code></pre>
<p>This is because free variables in a term-level <code>define</code> are cloned during recursion. Seeing how the above code is compiled might be illuminating:</p>
<pre><code class="language-neut">// `self` is now closed thanks to the new parameter `!m` (lambda lifting)
define self(counter: int, !m: text): unit {
  if ge-int(counter, 10) {
    Unit
  } else {
    // 💫 note that `!m` is used twice
    printf(&quot;message: {}\n&quot;, [!m]);
    self(add-int(counter, 1), !m)
  }
}

define multi-print(!message: text): unit {
  let f =
    function (counter: int) {
      self(counter, !message)
    }
  in
  f(0)
}
</code></pre>
<h3 id="cloning-values-for-free"><a class="header" href="#cloning-values-for-free">Cloning Values For Free</a></h3>
<p>The prefix <code>!</code> is unnecessary if the variable can be copied for free. For example, the following code will typecheck:</p>
<pre><code class="language-neut">define make-pair(x: int): pair(int, int) {
  Pair(x, x)
}
</code></pre>
<p>because we can &quot;copy&quot; integers for free (by simply using the same <code>x</code> twice).</p>
<h2 id="the-problem-excessive-copying"><a class="header" href="#the-problem-excessive-copying">The Problem: Excessive Copying</a></h2>
<p>Now, suppose we defined a function <code>length</code> as follows:</p>
<pre><code class="language-neut">define length(xs: list(int)): int {
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}
</code></pre>
<p>Also, suppose that we used this <code>length</code> as follows:</p>
<pre><code class="language-neut">define use-length(!xs: list(int)): unit {
  let len = length(!xs) in // use `length` to calculate the length of `!xs`
  some-function(len, !xs) // then use `len` and `!xs`
}
</code></pre>
<p>Note that the variable <code>!xs</code> is used twice. Therefore, in this example, the content of <code>!xs</code> is copied <em>just to calculate its length</em>. This is a disaster. The end of the world. Every wish is crushed into pieces.</p>
<p>Luckily, there is a loophole for this situation.</p>
<h2 id="the-solution-noema-type"><a class="header" href="#the-solution-noema-type">The Solution: Noema Type</a></h2>
<p>We need a way to bypass excessive copying. Here come <em>noema types</em>.</p>
<p>For any type <code>t</code>, Neut has a type <code>&amp;t</code>. We'll call this the noema type of <code>t</code>. Let's introduce some terminologies:</p>
<ul>
<li>We'll call a term <code>e</code> a noema if the type of <code>e</code> is a noema type.</li>
<li>We'll say that a term is noetic if the type of the term is a noema type.</li>
</ul>
<p>Unlike ordinary terms, <em>a noema isn't discarded or copied even when used non-linearly</em>. By using this behavior, we can avoid the disaster we have just seen.</p>
<p>Let's see how it works. We first redefine <code>length</code>. If the type <code>t</code> is an ADT type, you can inspect its content using <code>case</code>:</p>
<pre><code class="language-neut">define length(xs: &amp;list(int)): int {
  case xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}
</code></pre>
<p>The main difference between <code>case</code> and <code>match</code> is that <code>case</code> doesn't perform <code>free</code> against its arguments. Because of that, this new <code>length</code> doesn't consume <code>xs</code>.</p>
<p>Also, note that the newly-bound variables in <code>case</code> are automatically wrapped with <code>&amp;(_)</code>. For example, in the above example, the type of <code>ys</code> is not <code>list(int)</code>, but <code>&amp;list(int)</code>.</p>
<p>The <code>use-length</code> then becomes as follows:</p>
<pre><code class="language-neut">define use-length(xs: list(int)): unit {
  let len = length( ??? ) in
  some-function(len, xs)
}
</code></pre>
<p>We need a way to create a noetic version of <code>xs: list(int)</code>.</p>
<h2 id="creating-a-noema"><a class="header" href="#creating-a-noema">Creating a Noema</a></h2>
<p>We can create a noema using <code>let-on</code>.</p>
<pre><code class="language-neut">define use-length(xs: list(int)): unit {
  // 🌟
  let len on xs =
    // xs: &amp;list(int)
    length(xs)
  in
  // xs: list(int)
  some-function(len, xs)
}
</code></pre>
<p><code>on</code> takes a comma-separated list of variables. Variables specified there are then cast to a noema in the body of the <code>let</code> and cast back to non-noetic values in its continuation.</p>
<p>The syntax <code>let-on</code> is conceptually the following syntax sugar:</p>
<pre><code class="language-neut">let result on x = e in
cont

// ↓ desugar

let x = unsafe-cast(a, &amp;a, x) in // cast: `a` ~&gt; `&amp;a`
let result = e in                // (use `&amp;a`)
let x = unsafe-cast(&amp;a, a, x) in // uncast: `&amp;a` ~&gt; `a`
cont
</code></pre>
<p>We'll call the content of noetic value <code>xs</code> a <em>hyle</em>. In the example, the hyle of <code>xs</code> at <code>length(xs)</code> is <code>[1, 2, 3]</code>.</p>
<p>The result of <code>let-on</code> (that is, <code>len</code> in this case) can't include any noetic term. This restriction is required so that a noetic value won't outlive its hyle. If interested, please see the <a href="terms.html#on">corresponding part of the language reference</a> for more information.</p>
<h2 id="embodying-a-noema"><a class="header" href="#embodying-a-noema">Embodying a Noema</a></h2>
<p>Incidentally, you can also create a value of type <code>a</code> from a value of type <code>&amp;a</code>, as follows:</p>
<pre><code class="language-neut">define make-pair-from-noema&lt;a&gt;(x: &amp;a): pair(a, a) {
  Pair(*x, *x)
}
</code></pre>
<p>By writing <code>*e</code>, you can clone the hyle of the noema <code>e</code> along the type <code>a</code>, keeping the hyle intact.</p>
<h2 id="allocation-canceling"><a class="header" href="#allocation-canceling">Allocation Canceling</a></h2>
<p>Let's see another aspect of Neut's memory management. The compiler can sometimes optimize away memory allocation thanks to its static nature. Consider the following code:</p>
<pre><code class="language-neut">data int-list {
| Nil
| Cons(int, int-list)
}

// [1, 5, 9] =&gt; [2, 6, 10]
define increment(xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    Nil
  | Cons(x, rest) =&gt; // ← &quot;the `Cons` clause&quot;
    let foo = add-int(x, 1) in
    let bar = increment(rest) in
    Cons(foo, bar)
  }
}
</code></pre>
<p>The expected behavior of the <code>Cons</code> clause would be something like the following:</p>
<ol>
<li>obtain <code>x</code> and <code>rest</code> from <code>xs</code></li>
<li><code>free</code> the outer tuple of <code>xs</code></li>
<li>calculate <code>foo (= add-int(x, 1))</code> and <code>bar (= increment(rest))</code></li>
<li>allocate memory region using <code>malloc</code> to represent <code>Cons(foo, bar)</code></li>
<li>store the calculated values to the pointer and return it</li>
</ol>
<p>However, the compiler knows the following two facts during compilation:</p>
<ul>
<li>The size of outer tuples of <code>Cons(x, rest)</code> and <code>Cons(foo, bar)</code> are the same</li>
<li>The outer tuple of <code>Cons(x, rest)</code> will never be used after extracting its contents</li>
</ul>
<p>Thanks to this knowledge, the compiler can optimize away a pair of <code>free</code> and <code>malloc</code>, as follows:</p>
<ol>
<li>obtain <code>x</code> and <code>rest</code> from <code>xs</code></li>
<li>calculate <code>foo (= add-int(x, 1))</code> and <code>bar (= increment(rest))</code></li>
<li>store the calculated values to <code>xs</code> (overwrite)</li>
</ol>
<p>When a <code>free</code> is required, the compiler looks for a <code>malloc</code> in the continuation that is the same size and optimizes away such a pair if one exists. The resulting assembly code thus performs in-place updates.</p>
<h3 id="how-effective-is-this-optimization"><a class="header" href="#how-effective-is-this-optimization">How Effective Is This Optimization?</a></h3>
<p>Below is the result of benchmarking of a bubble sorting program. This test creates a random list of length <code>N</code> and performs bubble sort on the list.</p>
<p><img src="./image/graph/allocation-canceling.png" alt="allocation canceling" title="allocation canceling" /></p>
<p>This benchmark executes the following <code>sort</code> function:</p>
<pre><code class="language-neut">data int-list {
| My-Nil
| My-Cons(int, int-list)
}

nominal {
  _insert(v: int, xs: int-list): int-list,
}

// 🌟
inline _swap-gt(cond: bool, v: int, x: int, xs: int-list): int-list {
  if cond {
    My-Cons(x, _insert(v, xs))
  } else {
    My-Cons(v, My-Cons(x, xs))
  }
}

define _insert(v: int, xs: int-list): int-list {
  match xs {
  | My-Nil =&gt;
    My-Cons(v, My-Nil)
  | My-Cons(y, ys) =&gt;
    _swap-gt(gt-int(v, y), v, y, ys)
  }
}

define sort(xs: int-list, acc: int-list): int-list {
  match xs {
  | My-Nil =&gt;
    acc
  | My-Cons(y, ys) =&gt;
    sort(ys, _insert(y, acc))
  }
}

</code></pre>
<p>The above is the &quot;faster&quot; implementation of bubble sorting in Neut. The key person is <code>_swap-gt</code>. The above code defines <code>_swap-gt</code> as an inline function. Therefore, in <code>_insert</code>, the definition of <code>_swap-gt</code> is expanded, which makes allocation canceling of <code>My-Cons</code> in <code>_insert</code> possible.</p>
<p>The &quot;slower&quot; implementation can be obtained by replacing <code>inline</code> at the 🌟 with <code>define</code>. In this implementation, since the definition of <code>_swap-gt</code> can't be expanded in <code>_insert</code>, allocation canceling of <code>My-Cons</code> in <code>_insert</code> is not possible.</p>
<p>I also added the result of Haskell just for reference.</p>
<p>Additional notes:</p>
<ul>
<li>You can find the source files used in this benchmark <a href="https://github.com/vekatze/neut/tree/main/bench/action/bubble/source">here</a>.</li>
<li>I used my M1 Max MacBook Pro (32GB) to run this benchmark.</li>
</ul>
<p>If you're interested in more benchmarking results, please see <a href="./benchmarks.html">Benchmarks</a>.</p>
<h2 id="what-youve-learned-here"><a class="header" href="#what-youve-learned-here">What You've Learned Here</a></h2>
<ul>
<li>Neut uses noema types to bypass copying resources</li>
<li>The compiler finds pairs of <code>malloc/free</code> that are the same size and optimizes them away</li>
</ul>

            <footer id="footer-paginator">
              <a rel="prev" href="programming-in-neut.html" class="nav previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                ← Previous Page
              </a>

              <div id="footer-spacer"></div>

              <a rel="next" href="modality-and-memory.html" class="nav next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                Next Page →
              </a>
            </footer>
          </article>
          <div id="footer-wrapper">
            <footer id="footer-nav">
              <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-external-world.html"><strong aria-hidden="true">3.1.</strong> Hello External World</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html" class="active"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
            </footer>
          </div>
        </main>
      </div>


      <script src="highlight.js"></script>
      <script src="book.js"></script>
    </div>
  </body>
</html>
