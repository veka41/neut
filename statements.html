<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Statements - Neut Programming Language</title>
    <meta name="description" content="A functional programming language with static memory management." />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="css/general.css" />
    <link rel="stylesheet" href="highlight.css" />
    <meta property="og:title" content="Statements - Neut Programming Language" />
    <meta property="og:description" content="A functional programming language with static memory management." />
    <meta property="og:url" content="https://vekatze.github.io/neut/statements.md" />
    <meta property="og:type" content="article" />
  </head>
  <body>
    <div id="body-container">
      <header id="menu-bar">
        <h1 class="menu-title">
          <a href="overview.html">
            Neut Programming Language
          </a>
        </h1>

        <div class="right-buttons">
            <a href="https://github.com/vekatze/neut" class="menubar-item">
              <span>GitHub</span>
            </a>
        </div>
      </header>
      <div id="content-box">
        <aside id="sidebar">
          <nav class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-external-world.html"><strong aria-hidden="true">3.1.</strong> Hello External World</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html" class="active"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
          </nav>
        </aside>

        <main id="content" tabindex="0">
          <article id="content-inner">
            <h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#import">import</a></li>
<li><a href="#define">define</a></li>
<li><a href="#inline">inline</a></li>
<li><a href="#data">data</a></li>
<li><a href="#resource">resource</a></li>
<li><a href="#nominal">nominal</a></li>
<li><a href="#foreign">foreign</a></li>
</ul>
<h2 id="import"><a class="header" href="#import"><code>import</code></a></h2>
<p><code>import</code> imports names from other files. It should look like the following:</p>
<pre><code class="language-neut">import {
  Qux,
  ZZ,
  sample.buz,
  this.foo,
  this.item.bar {some-func, other-func},
}
</code></pre>
<p><code>import</code> can only be at the top of a file.</p>
<h3 id="regular-entry"><a class="header" href="#regular-entry">Regular Entry</a></h3>
<p>A regular entry in <code>import</code> is something like the following:</p>
<ul>
<li><code>this.foo</code></li>
<li><code>this.item.bar {some-func, other-func}</code></li>
<li><code>sample.buz</code></li>
</ul>
<p>A regular entry starts from the alias of the module (<code>this</code>, <code>sample</code>). The alias of the module is specified in <code>dependency</code> in <code>module.ens</code>. If the file we want to import is inside the current module, we'll write <code>this</code>.</p>
<p>The remaining part of the regular entry is the relative path from the source directory. For example, if we want to import <code>(source-dir)/item/bar</code>, we'll have to write <code>item.bar</code> after the alias of the module.</p>
<p>A regular entry can be constructed by concatenating the alias and the path with <code>.</code>. In the case of <code>this.item.bar</code>, the alias part is <code>this</code>, and the path part is <code>item.bar</code>.</p>
<p>You can specify names in <code>{}</code>. The names specified here can be used without qualifiers:</p>
<pre><code class="language-neut">import {
  this.item.bar {some-func},
}

define yo(): unit {
  some-func(arg-1, arg-2)
}
</code></pre>
<p>Unlisted names must be qualified:</p>
<pre><code class="language-neut">import {
  this.item.bar,
}

define yo(): unit {
  this.item.bar.some-func(arg-1, arg-2)
}
</code></pre>
<p>You can also list static files in <code>import</code>:</p>
<pre><code class="language-neut">import {
  static {some-file, other-file}
}
</code></pre>
<p>For more on static files, please see <a href="modules.html#static">the section in Modules</a>.</p>
<h3 id="prefix-entry"><a class="header" href="#prefix-entry">Prefix Entry</a></h3>
<p>A prefix entry in <code>import</code> is something like <code>Qux</code> or <code>ZZ</code>. That is, a capitalized name that doesn't contain any <code>.</code>.</p>
<p>A prefix entry in <code>import</code> must be defined in the <code>prefix</code> of the current module's <code>module.ens</code>. Suppose that <code>module.ens</code> contains the following:</p>
<pre><code class="language-ens">{
  // ..
  prefix {
    Qux &quot;this.item.bar&quot;,
  },
  // ..
}
</code></pre>
<p>Then, the code</p>
<pre><code class="language-neut">import {
  this.item.bar,
}

define use-some-func(): unit {
  this.item.bar.some-func()
}
</code></pre>
<p>can be rewritten into:</p>
<pre><code class="language-neut">import {
  Qux,
}

define use-some-func(): unit {
  Qux.some-func()
}
</code></pre>
<p>You may also want to see the explanation of <code>prefix</code> in <a href="./modules.html">Modules</a>.</p>
<h2 id="define"><a class="header" href="#define"><code>define</code></a></h2>
<p><code>define</code> defines a function. It should look like the following:</p>
<pre><code class="language-neut">define foo(x: int, y: int): int {
  add-int(x, y)
}

define identity-1(a: type, x: a): a {
  x
}

// a function with an implicit argument
define identity-2&lt;a&gt;(x: a): a {
  x
}
</code></pre>
<p>Defined functions can then be used:</p>
<pre><code class="language-neut">define use-foo(): int {
  foo(1, 2)
}
</code></pre>
<p><code>define</code> can optionally have implicit arguments, as in <code>identity-2</code> in the above example. The compiler inserts these implicit arguments at compile time, so you don't have to write them explicitly:</p>
<pre><code class="language-neut">define use-func-with-implicit-arg(): int {
  let x = 10 in
  let y = identity-1(int, x) in // ← explicit version
  let z = identity-2(x) in      // ← implicit version
  z
}
</code></pre>
<p>You can also use <code>define</code> without any explicit arguments:</p>
<pre><code class="language-neut">define foo: int {
  10
}

define empty-list&lt;a&gt;: list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo in
  empty-list
}
</code></pre>
<p>The above code is translated into the following during compile time:</p>
<pre><code class="language-neut">define foo(): int {
  10
}

define empty-list&lt;a&gt;(): list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo() in
  empty-list()
}
</code></pre>
<p>The compiler tries to reduce the body of a <code>define</code> into a value at compile time if the <code>define</code> doesn't have any explicit arguments. The compiler reports an error if it can't get a value. For example, the following should result in an error:</p>
<pre><code class="language-neut">define bar: int {
  print(&quot;hello&quot;);
  123
}
</code></pre>
<p>A function with the same name can't be defined in the same file.</p>
<p>All the tail-recursions in Neut are optimized into loops (thanks to geniuses in the LLVM team).</p>
<p>Note that statements are order-sensitive as in F#. Thus, the following code results in an error:</p>
<pre><code class="language-neut">define bar(): int {
  foo() // `foo` is undefined here
}

define foo(): int {
  10
}
</code></pre>
<p>You have to use the statement <code>nominal</code> explicitly for forward references.</p>
<h2 id="inline"><a class="header" href="#inline"><code>inline</code></a></h2>
<p><code>inline</code> defines an inline function. It should look like the following:</p>
<pre><code class="language-neut">inline foo(x: int, y: int): int {
  print(&quot;foo&quot;);
  add-int(x, y)
}
</code></pre>
<p><code>inline</code> is the same as <code>define</code> except that the definition is always expanded at compile-time. For example, if you write</p>
<pre><code class="language-neut">define use-inline-foo(): int {
  let val =
    foo(10, 20)
  in
  val
}
</code></pre>
<p>The compiler will translate the above code into the following:</p>
<pre><code class="language-neut">define use-inline-foo(): int {
  let val =
    let tmp1 = 10 in
    let tmp2 = 20 in
    print(&quot;foo&quot;);
    add-int(tmp1, tmp2)
  in
  val
}
</code></pre>
<p>You can also use <code>inline</code> without any explicit arguments:</p>
<pre><code class="language-neut">inline foo: int {
  10
}

inline empty-list&lt;a&gt;: list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo in
  empty-list
}
</code></pre>
<p>The above code is translated into the following during compile time:</p>
<pre><code class="language-neut">inline foo(): int {
  10
}

inline empty-list&lt;a&gt;(): list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo() in
  empty-list()
}
</code></pre>
<p>The compiler tries to reduce the body of an <code>inline</code> into a value at compile time if the <code>inline</code> doesn't have any explicit arguments. The compiler reports an error if it can't get a value. For example, the following should result in an error:</p>
<pre><code class="language-neut">inline bar: int {
  print(&quot;hello&quot;);
  123
}
</code></pre>
<h2 id="data"><a class="header" href="#data"><code>data</code></a></h2>
<p><code>data</code> defines an algebraic data type (ADT). It should look like the following:</p>
<pre><code class="language-neut">data nat {
| Zero
| Succ(nat)
}

data list(a) {
| Nil
| Cons(a, list(a))
}

data config {
| Config(
    count: int,
    foo-path: &amp;text,
    colorize: bool,
  )
}
</code></pre>
<p>You can use the content of an ADT value by using <code>match</code> or <code>case</code>:</p>
<pre><code class="language-neut">define length&lt;a&gt;(xs: list(a)): int {
  // destruct ADT values using `match`
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}

define length-noetic&lt;a&gt;(xs: &amp;list(a)): int {
  // read noetic ADT values using `case`
  case xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length-noetic(ys))
  }
}

define use-config(c: config) {
  // pattern-matching in `let` is also possible
  let Config of {count, some-path} = c in
  print(count)
}
</code></pre>
<h2 id="resource"><a class="header" href="#resource"><code>resource</code></a></h2>
<p><code>resource</code> defines a new type by specifying how to discard/copy the values of the type. It should look like the following:</p>
<pre><code class="language-neut">resource my-new-type {
  function (value: pointer) {
    // .. discard the value ..
  },
  function (value: pointer) {
    // .. create a new clone of the value and return it as int ..
  },
}
</code></pre>
<p><code>resource</code> takes two terms. The first term (&quot;discarder&quot;) receives a value of the type and discards the value. The second term (&quot;copier&quot;) receives a value of the type and returns the clone of the value (keeping the original value intact).</p>
<p>The type of a discarder is <code>(a) -&gt; unit</code> for some <code>a</code>. You might want to call functions like <code>free</code> in this term.</p>
<p>The type of a copier is <code>(int) -&gt; int</code> for some <code>a</code>. This <code>a</code> must be the same as the <code>a</code> used in the discarder. You might want to call functions like <code>malloc</code> in this term.</p>
<p>For example, the following is a definition of a &quot;boxed&quot; integer type with some noisy messages:</p>
<pre><code class="language-neut">resource boxed-int {
  // discarder: (pointer) -&gt; unit
  function (v: pointer) {
    print(&quot;discarded!\n&quot;);
    free(v)
  },
  // copier: (pointer) -&gt; pointer
  function (v: pointer) {
    let orig-value = load-int(v) in
    let new-ptr = malloc(1) in
    magic store(int, orig-value, new-ptr);
    new-ptr
  },
}

// provide a way to introduce new boxed integer
define create-new-boxed-int(x: int): boxed-int {
  let new-ptr = malloc(8) in
  store-int(x, new-ptr);
  magic cast(int, boxed-int, new-ptr)
}
</code></pre>
<p>A value of type <code>boxed-int</code> prints <code>&quot;discarded!\n&quot;</code> when the value is discarded.</p>
<p><code>resource</code> can be used to define low-level types like arrays.</p>
<p>You can find an example usage of <code>resource</code> in the <code>binary.nt</code> in the <a href="https://github.com/vekatze/neut-core/blob/main/source/binary.nt">core library</a>.</p>
<h2 id="nominal"><a class="header" href="#nominal"><code>nominal</code></a></h2>
<p><code>nominal</code> declares functions for forward references. It should look like the following:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int,
}
</code></pre>
<p>An entry of <code>nominal</code> is the same form as found in <code>define</code>. Nominal definitions can be used to achieve mutual recursions:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int, // nominal definition of `is-odd`
}

// given a non-negative integer `x`, returns true if `x` is even.
define is-even(x: int): bool {
  if eq-int(x, 0) {
    True
  } else {
    is-odd(sub-int(x, 1)) // ← using nominal definition
  }
}

// given a non-negative integer `x`, returns true if `x` is odd.
// (&quot;real&quot; definition of `is-odd`)
define is-odd(x: int): bool {
  if eq-int(x, 0) {
    False
  } else {
    is-even(sub-int(x, 1))
  }
}
</code></pre>
<p>If a nominal definition isn't followed by a real definition, the compiler reports an error.</p>
<h2 id="foreign"><a class="header" href="#foreign"><code>foreign</code></a></h2>
<p><code>foreign</code> declares functions that are defined in linked objects. It should look like the following:</p>
<pre><code class="language-neut">foreign {
  neut_myapp_v1_add_const(int): int,
}
</code></pre>
<p>Foreign functions declared here can be called by using <code>magic external(..)</code>.</p>
<p>Suppose that you have a C source file with the following definition:</p>
<pre><code class="language-c">// add_const.c

int neut_myapp_v1_add_const(int value) {
  return value + 100;
}
</code></pre>
<p>You can add the field <code>foreign</code> to your <code>module.ens</code> to compile and link this C source file, as written <a href="modules.html#foreign">here</a>. Under this setting, the following code can utilize <code>neut_myapp_v1_add_const</code>:</p>
<pre><code class="language-neut">foreign {
  neut_myapp_v1_add_const(int): int,
}

define main(): unit {
  let x: int = 10 in
  print-int(magic external neut_myapp_v1_add_const(x)); // ← `magic external` is used here
  print(&quot;\n&quot;)
}
</code></pre>
<p>An example project that uses <code>foreign</code> can be found <a href="https://github.com/vekatze/neut/tree/main/test/misc/foreign">here</a>.</p>
<p>You can also use LLVM intrinsics. For example, the LLVM langref states that <code>llvm.sin.*</code> intrinsic is <a href="https://llvm.org/docs/LangRef.html#llvm-sin-intrinsic">available</a>:</p>
<pre><code class="language-llvm">declare float     @llvm.sin.f32(float  %Val)
declare double    @llvm.sin.f64(double %Val)
declare x86_fp80  @llvm.sin.f80(x86_fp80  %Val)
declare fp128     @llvm.sin.f128(fp128 %Val)
declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128  %Val)
</code></pre>
<p>Thus, the next is a valid use of <code>foreign</code>:</p>
<pre><code class="language-neut">foreign {
  llvm.sin.f64(float): float,
}

define sin(x: float): float {
  magic external llvm.sin.f64(x)
}
</code></pre>
<p>Syscall wrapper functions and library functions are also available:</p>
<pre><code class="language-neut">foreign {
  exit(c-int): void,
  sleep(c-int): c-int,
}
</code></pre>
<p>Here, the definition of <code>c-int</code> is as follows:</p>
<pre><code class="language-neut">inline _c-int: type {
  introspect architecture {
  | amd64 =&gt;
    int32
  | arm64 =&gt;
    int32
  }
}

data c-int {
| C-Int(_c-int)
}
</code></pre>
<p>The type of each argument in every foreign entry must be a term that compiles to one of <code>int{N}</code>, <code>float{N}</code>, or <code>pointer</code> during compilation. For example, the <code>c-int</code> in <code>exit(c-int): void</code> is valid because it compiles to <code>int32</code> (thanks to an optimization like Haskell's <code>newtype</code>).</p>
<p>The resulting type of every foreign entry must be <code>void</code> or a term that compiles to one of <code>int{N}</code>, <code>float{N}</code>, or <code>pointer</code> during compilation.</p>
<p>When declaring a variadic function, declare only the non-variadic part:</p>
<pre><code class="language-neut">foreign {
  printf(pointer): void,
}
</code></pre>
<p>Then, specify the types of variadic arguments when using <code>magic external</code>:</p>
<pre><code class="language-neut">define print(t: &amp;text): unit {
  // ..
  magic external printf(fmt)(len: int, val: pointer)
  //                         ^^^^^^^^^^^^^^^^^^^^^^
  //                         passing variadic arguments with types
}
</code></pre>

            <footer id="footer-paginator">
              <a rel="prev" href="modules.html" class="nav previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                ← Previous Page
              </a>

              <div id="footer-spacer"></div>

              <a rel="next" href="terms.html" class="nav next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                Next Page →
              </a>
            </footer>
          </article>
          <div id="footer-wrapper">
            <footer id="footer-nav">
              <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-external-world.html"><strong aria-hidden="true">3.1.</strong> Hello External World</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html" class="active"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
            </footer>
          </div>
        </main>
      </div>


      <script src="highlight.js"></script>
      <script src="book.js"></script>
    </div>
  </body>
</html>
